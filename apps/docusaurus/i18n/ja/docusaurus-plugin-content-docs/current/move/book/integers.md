# 整数(インテジャー)

Moveは`u8`、`u16`、`u32`、`u64`、`u128`、`u256`の6つの符号無し整数型をサポートします。これらの型の値は、0から型のサイズに応じた最大値までの範囲となります。


| 型                             | 値の範囲              |
| -------------------------------- | ------------------------ |
| 符号無し 8ビット 整数、 `u8`     | 0 から 2<sup>8</sup> - 1   |
| 符号無し 16ビット 整数、 `u16`   | 0 から 2<sup>16</sup> - 1  |
| 符号無し 32ビット 整数、 `u32`   | 0 から 2<sup>32</sup> - 1  |
| 符号無し 64ビット 整数、 `u64`   | 0 から 2<sup>64</sup> - 1  |
| 符号無し 128ビット 整数、 `u128` | 0 から 2<sup>128</sup> - 1 |
| 符号無し 256ビット 整数、 `u256` | 0 から 2<sup>256</sup> - 1 |

## リテラル

これらの型のリテラル値は、数字のシーケンス(例: `112`)または16進リテラル(例:`0xFF`)として指定されます。リテラルの型はオプションで接尾辞(例:`112u8`)として追加できます。型が指定されていない場合、コンパイラはリテラルが使用されているコンテキストから型を推測しようとします。型を推測できない場合は、`u64`であると見なされます。

数値リテラルは、グループ化と読みやすさのためアンダースコアで区切る事が出来ます。(例:`1_234_5678`、`1_000u128`、`0xAB_CD_12_35`)

リテラルが指定された（または推定された）サイズ範囲に対して大き過ぎる場合は、エラーが報告されます。

### 例

```move
script {
  fun example() {
    // 明白な注釈が付いたリテラル
    let explicit_u8 = 1u8;
    let explicit_u16 = 1u16;
    let explicit_u32 = 1u32;
    let explicit_u64 = 2u64;
    let explicit_u128 = 3u128;
    let explicit_u256 = 1u256;
    let explicit_u64_underscored = 154_322_973u64;

    // 単純な推論のリテラル
    let simple_u8: u8 = 1;
    let simple_u16: u16 = 1;
    let simple_u32: u32 = 1;
    let simple_u64: u64 = 2;
    let simple_u128: u128 = 3;
    let simple_u256: u256 = 1;

    // より複雑な推論のリテラル
    let complex_u8 = 1; // 推測: u8
    // 右側の引数はu8へシフトしなければなりません
    let _unused = 10 << complex_u8;

    let x: u8 = 38;
    let complex_u8 = 2; // 推測: u8
    // 引数から`+`は同じ型でなければなりません。 
    let _unused = x + complex_u8;

    let complex_u128 = 133_876; // 推測: u128
    // 関数の引数の型から推測
    function_that_takes_u128(complex_u128);

    // リテラルは16真数で記述出来ます
    let hex_u8: u8 = 0x1;
    let hex_u16: u16 = 0x1BAE;
    let hex_u32: u32 = 0xDEAD80;
    let hex_u64: u64 = 0xCAFE;
    let hex_u128: u128 = 0xDEADBEEF;
    let hex_u256: u256 = 0x1123_456A_BCDE_F;
  }
}
```

## 演算

### 算術

これらの各型は、同じチェック付き算術演算のセットをサポートしています。これらの全ての演算では、両方の引数 (左側のオペランドと右側のオペランド) が同じ型である _必要があります_ 。異なる型の値を演算する必要がある場合はまず、[キャスト](#casting)を実行する必要が有ります。同様に、演算の結果が整数型に対して大きすぎると予想される場合は、
演算を実行する前に、より大きなサイズへ[キャスト](#casting)を実行します。

すべての算術演算は、数学的な整数では考えられないような動作(オーバーフロー、アンダーフロー、ゼロ除算など)をするのではなく、中止されます。

| 構文 | 演算           | 以下の場合中止                                |
| ------ | ------------------- | ---------------------------------------- |
| `+`    | 加算            | 結果が整数型に対して大き過ぎる |
| `-`    | 減算         | 結果がゼロ未満                 |
| `*`    | 乗算      | 結果が整数型に対して大きすぎる |
| `%`    | モジュラー除算    |      除数が `0`                  |
| `/`    | 切り捨て除算 | 除数が `0`                       |

### ビット単位

整数型は、各数値を数値の整数値としてではなく、0または1の一連の個別のビットとして扱う以下のビット単位の演算をサポートします。

ビット演算は中止されません。

| 構文              | 演算   |                                      説明      |
| ------------------- | ----------- | ----------------------------------------------------- |
| `&`       | ビット単位 and | ブール値 and を各ビットペア単位で実行         |
| <code>&#124;</code> | ビット単位 or  | ブール値 or を各ビットペア単位で実行           |
| `^`                 | ビット単位 xor | ブール値 exclusive or(排他的論理和) を各ビットペア単位で実行 |

### ビットシフト

ビット演算と同様に、各整数型はビットシフトをサポートします。ただし、他の演算とは異なり右側のオペランド(シフトするビット数)は _常に_ `u8`である必要があり、左側のオペランド(シフトする数値)と一致する必要はありません。

およびの場合、シフトするビット数`u8`、`u16`、`u32`、`u64`、`u128`、`u256`がそれぞれ`8`、`16`、`32`、`64`、`128`、`256`と同等または以上の場合、ビットシフトは中止される事が有ります。

| 構文 | 演算   | 以下の場合中止                                               |
| ------ | ----------- | ----------------------------------------------------------------------- |
| `<<`   | 左へシフト  | シフトするビット数が整数型のサイズよりも大きい |
| `>>`   | 右へシフト | シフトするビット数が整数型のサイズより大きい |

### 比較

整数型は、Moveで比較演算子を使用出来る _唯一の_ 型です。両方の引数は同じ型である必要が有ります。異なる型の整数を比較する必要がある場合は、まずその内のひとつを[キャスト](#casting)する必要が有ります。

比較演算は中止されません。

| 構文 | 演算                |
| ------ | ------------------------ |
| `<`    | 未満                |
| `>`    | よりも大きい             |
| `<=`   | 以下   |
| `>=`   | 以上 |

### 等価

Move内の全ての [`drop`](./abilities.md)型と同様、全ての整数型は["等しい"](./equality.md)と ["等しくない"](./equality.md)演算をサポートします。両方の引数は同じ型である必要が有ります。異なる型の整数を比較する必要が有る場合は、まずその内のひとつを[キャスト](#casting)する必要が有ります。

等価演算は中止されません。

| 構文 | 演算 |
| ------ | --------- |
| `==`   | 等しい     |
| `!=`   | 等しくない |

詳細は[等価](./equality.md)のセクションを御覧下さい。

## キャスティング

あるサイズの整数型は、別のサイズの整数型へキャストできます。整数は、Moveでキャストをサポートする唯一の型です。

キャストは切り捨て _られません_。結果が指定された型に対して大きすぎる場合、キャストは中止されます。


| 構文     | 演算                                            | 以下の場合中止                              |
| ---------- | ---------------------------------------------------- | -------------------------------------- |
| `(e as T)` | 整数式`e`を整数型`T`へキャストする | `T`として表すには`e`は大き過ぎる |

ここで`e`の型は`8`、`16`、`32`、`64`、`128`、`256`であり、`T`は`u8`、`u16`、`u32`、`u64`、`u128`、`u256`である必要が有ります。

例えば:

- `(x as u8)`
- `(y as u16)`
- `(873u16 as u32)`
- `(2u8 as u64)`
- `(1 + 3 as u128)`
- `(4/2 + 12345 as u256)`

## 所有権

言語に組み込まれている他のスカラー値と同様、整数値は暗黙的にコピー可能です。即ち、[`copy`](./variables.md#move-and-copy)等の明示的な命令無しでコピー出来ます。
 