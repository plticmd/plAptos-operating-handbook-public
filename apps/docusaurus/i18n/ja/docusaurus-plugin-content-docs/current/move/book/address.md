# アドレス

`address`は、Moveの組み込み型であり、グローバル ストレージ内の場所 (アカウントと呼ばれることもあります) を表すため使用されます。`address`値は256ビット(32バイト)の識別子です。特定のアドレスには[モジュール](./modules-and-scripts.md)と [リソース](./structs-and-resources.md)の2つを保存できます。


`address`は内部では 256ビットの整数ですが、Move アドレスは意図的に不透明となっています。---整数から作成出来ず、算術演算をサポートせず、変更が出来ません。このような機能を使用する興味深いプログラムが存在する可能性はありますが (例えば、Cのポインタ演算は同様の隙間を埋めます)、Moveは静的検証をサポートするためゼロから設計されているので、この動的な動作を許可しません。

実行時のアドレス値(`address`型の値)を使用して、そのアドレスのリソースへアクセス出来ます。実行時にアドレス値を介してモジュールにアクセスする事は出来ません。

## アドレスとその構文

アドレスには、名前付きと数値の2種類が有ります。名前付きアドレスの構文は、Moveの任意の名前付き識別子と同じルールへ従います。数値アドレスの構文は16進数でエンコードされた値に制限されず、有効な[`u256`数値](./integers.md)はアドレス値として使用出来ます。例えば`42`、`0xCAFE`、`2021`は全て有効な数値アドレスリテラルです。

アドレスが式のコンテキストで使用されているかどうかを区別するため、アドレスを使用する際の構文は、使用されるコンテキスト次第で異なります。

- アドレスを式として使用する場合、アドレスは`@`文字の接頭辞を付ける必要が有ります。即ち、[`@<numerical_value>`](./integers.md)もしくは`@<named_address_identifier>`。
- 式のコンテキスト外では、アドレスは先頭の`@`文字無しで記述できます（即ち[`<numerical_value>`](./integers.md)もしくは`<named_address_identifier>`。

一般的に`@`は、アドレスをネームスペース項目から式項目へ変換する演算子として考える事が出来ます。

## 名前付きアドレス

名前付きアドレスは、値レベルだけでなく、アドレスが使用されるあらゆる場所で数値のかわりに識別子を使用出来る様にする機能です。名前付きアドレスは、Move パッケージでトップレベルの要素 (モジュールとスクリプトの外部)として宣言および拘束されるか、Moveコンパイラーへ引数として渡されます。


名前付きアドレスはソース言語レベルでのみ存在し、バイトコードレベルでは完全にその値へ置き換えられます。このため、モジュールとモジュールメンバーは、モジュールの名前付きアドレスを介してアクセスする必要があります。（コンパイル時に名前付きアドレスに割り当てられた数値を介してではなく。）
例えば、Moveプログラムが `my_addr`を`0x2`へ設定してコンパイルされた場合でも、`use my_addr::foo`は`use 0x2::foo`と _同等ではありません_ 。この違いについては[モジュールとスクリプト](./modules-and-scripts.md)のセクションで詳しく議論されています。

### 例

```move
let a1: address = @0x1; //0x0000000000000000000000000000000000000000000000000000000000000001 の略記
let a2: address = @0x42; // s0x0000000000000000000000000000000000000000000000000000000000000042 の略記
let a3: address = @0xDEADBEEF; // 0x00000000000000000000000000000000000000000000000000000000DEADBEEF の略記
let a4: address = @0x000000000000000000000000000000000000000000000000000000000000000A;
let a5: address = @std; // `a5`へ名前つきアドレス`std`の値を代入します
let a6: address = @66;
let a7: address = @0x42;

module 66::some_module {   // 式コンテキスト内ではないため@は必要有りません
    use 0x1::other_module; // 式コンテキスト内ではないため@は必要有りません
    use std::vector;       // 他のモジュールを使用する時、名前付きアドレスをネームスペース項目として使用出来ます。
    ...
}

module std::other_module {  // 名前付きアドレスをネームスペース項目として使用してモジュールを宣言出来ます。
    ...
}
```

## グローバルストレージオペレーション

`address`値の主な目的は、グローバルストレージオペレーションと対話する事です。

`address`値は`exists`、`borrow_global`、`borrow_global_mut`、`move_from`[operations](./global-storage-operators.md)で使用されます。

`address`を _使用しない_ 唯一のグローバルストレージオペレーションは`move_to`であり[`signer`](./signer.md)を使用します。

## 所有権

言語に組み込まれている他のスカラー値と同様、`address`値は暗黙的にコピー可能です。即ち、[`copy`](./variables.md#move-and-copy)の様な明白な命令無しでコピー出来ます。
