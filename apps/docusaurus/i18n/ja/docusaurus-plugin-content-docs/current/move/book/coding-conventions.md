# Moveコーディング規則

このセクションでは、Moveチームが役立つと判断した、Moveの基本的なコーディング規則をいくつか解説します。これらは推奨事項に過ぎないので、他の書式ガイドラインや規則を希望する場合は、遠慮なく使用して下さい。

## 命名

- **モジュール名**: 小文字のスネークケースにする必要があります (例:`fixed_point32`、`vector`)。
- **型名**: ネイティブ型でない場合は、キャメルケースにする必要があります(例:`Coin`、`RoleId`)。
- **関数名**: 小文字のスネークケースにする必要があります。例: `destroy_empty`。
- **定数名**: エラーコードを表す場合は大文字のキャメルケースで`E`で始まる必要が有り(例: `EIndexOutOfBounds`)、エラー以外の値を表す場合は大文字のスネークケースです(例: `MIN_STAKE`)。

- **ジェネリック型名**: 適切な場合は記述的、または非記述的にする必要が有ります(例: ベクタージェネリック型パラメータの場合`T`または`Element`)。殆どの場合、モジュール内の「メイン」型はモジュールと同じ名前にする必要が有ります(例: `option::Option`、`fixed_point32::FixedPoint32`)。
- **モジュール ファイル名**: モジュール名と同じである必要が有ります(例:`option.move`)。
- **スクリプト ファイル名**: 小文字のスネークケースで、スクリプト内の「main」関数の名前と一致する必要が有ります。
- **混合ファイル名**: ファイルが複数のモジュールやスクリプトを含んでいる場合、ファイル名は小文字のスネークケースにする必要があります。ファイル名は、内部の特定のモジュール/スクリプトと一致しません。

## インポート

- 全てのモジュール`use`ステートメントはモジュールの先頭へ配置する必要が有ります。
- 関数は、宣言したモジュールから完全限定的にインポ​​ートされ、使用される必要が有ります。そして、最上位レベルでインポートされません。
- 型は最上位レベルでインポートする必要があります。名前が競合する場合は、ローカルでの型の適切な名前変更で`as`を使用する必要が有ります。

例えば, モジュールがある場合:

```move
module 0x1::foo {
    struct Foo { }
    const CONST_FOO: u64 = 0;
    public fun do_foo(): Foo { Foo{} }
    ...
}
```

これは以下の様にインポートされ使用されます:

```move
module 0x1::bar {
    use 0x1::foo::{Self, Foo};

    public fun do_bar(x: u64): Foo {
        if (x == 10) {
            foo::do_foo()
        } else {
            abort 0
        }
    }
    ...
}
```

2つのモジュールをインポートする時、ローカルの名前の競合が発生した場合は:

```move
module 0x1::other_foo {
    struct Foo {}
    ...
}

module 0x1::importer {
    use 0x1::other_foo::Foo as OtherFoo;
    use 0x1::foo::Foo;
    ...
}
```

## コメント

- 各モジュール、構造体、パブリック関数の宣言にはコメントを付ける必要が有ります。
- Moveにはドキュメントコメント`///`、通常の1行コメント`//`、ブロックコメント`/* */`、ブロックドキュメントコメント`/** */`が有ります。

## 書式設定

Moveチームは、書式設定規則を強制する自動フォーマッターを作成する予定です。ただし、作成するまでの間は:

- 内容がインデントされない`script`と`address`ブロックを除き、4つのスペースによるインデントを使用する必要が有ります。
- 行が100文字を超える場合は、行を折り返す必要があります。
- 構造体と定数は、モジュール内の全ての関数の前に宣言する必要が有ります。
