"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[5571],{13284:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var s=i(63159),t=i(83581);const a={title:"Move Specification Language"},o="Expressions",r={id:"move/prover/spec-lang",title:"Move Specification Language",description:"This document describes the Move specification language (MSL), a subset of the Move language that supports specification of the behavior of Move programs. MSL works together with the Move Prover, a tool that can statically verify the correctness of MSL specifications against Move programs. In contrast to traditional testing, verification of MSL is exhaustive and holds for all possible inputs and global states of a Move module or Move script. At the same time, this verification of MSL is fast and automated enough that it can be used at a similar place in the developer workflow where tests are typically conducted (for example, for qualification of pull requests in continuous integration).",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/prover/spec-lang.md",sourceDirName:"move/prover",slug:"/move/prover/spec-lang",permalink:"/move/prover/spec-lang",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/prover/spec-lang.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{title:"Move Specification Language"},sidebar:"appSidebar",previous:{title:"Move Prover\u30e6\u30fc\u30b6\u30fc\u30ac\u30a4\u30c9",permalink:"/move/prover/prover-guide"},next:{title:"Supporting Resources",permalink:"/move/prover/supporting-resources"}},c={},l=[{value:"Type System",id:"type-system",level:2},{value:"Naming",id:"naming",level:2},{value:"Operators",id:"operators",level:2},{value:"Function calls",id:"function-calls",level:2},{value:"Statements",id:"statements",level:2},{value:"Pack and unpack",id:"pack-and-unpack",level:2},{value:"Quantifiers",id:"quantifiers",level:2},{value:"Choice operator",id:"choice-operator",level:2},{value:"Cast operator",id:"cast-operator",level:2},{value:"Shift operator",id:"shift-operator",level:2},{value:"Bitwise operators",id:"bitwise-operators",level:2},{value:"Built-in functions",id:"built-in-functions",level:2},{value:"Partial semantics",id:"partial-semantics",level:2},{value:"Separating specifications",id:"separating-specifications",level:2},{value:"Pragmas and properties",id:"pragmas-and-properties",level:2},{value:"Pragma inheritance",id:"pragma-inheritance",level:3},{value:"General pragmas and properties",id:"general-pragmas-and-properties",level:3},{value:"Pre and post state",id:"pre-and-post-state",level:2},{value:"Helper functions",id:"helper-functions",level:2},{value:"Uninterpreted functions",id:"uninterpreted-functions",level:3},{value:"Axioms",id:"axioms",level:3},{value:"Let bindings",id:"let-bindings",level:2},{value:"Aborts_if condition",id:"aborts_if-condition",level:2},{value:"Aborts_if condition with code",id:"aborts_if-condition-with-code",level:3},{value:"Aborts_with condition",id:"aborts_with-condition",level:2},{value:"Requires condition",id:"requires-condition",level:2},{value:"Ensures condition",id:"ensures-condition",level:2},{value:"Modifies condition",id:"modifies-condition",level:2},{value:"Invariant condition",id:"invariant-condition",level:2},{value:"Function invariants",id:"function-invariants",level:3},{value:"Struct invariants",id:"struct-invariants",level:3},{value:"Global invariants",id:"global-invariants",level:3},{value:"Disabling invariants",id:"disabling-invariants",level:4},{value:"Update invariants",id:"update-invariants",level:4},{value:"Isolated global invariants",id:"isolated-global-invariants",level:4},{value:"Modular verification and global invariants",id:"modular-verification-and-global-invariants",level:4},{value:"Assume and assert conditions in code",id:"assume-and-assert-conditions-in-code",level:2},{value:"Loop invariants",id:"loop-invariants",level:3},{value:"Referring to pre-state",id:"referring-to-pre-state",level:3},{value:"Specification variables",id:"specification-variables",level:2},{value:"Schemas",id:"schemas",level:2},{value:"Basic Schema Usage",id:"basic-schema-usage",level:3},{value:"Schema expressions",id:"schema-expressions",level:3},{value:"Schema apply operation",id:"schema-apply-operation",level:3},{value:"Opaque specifications",id:"opaque-specifications",level:2},{value:"Abstract specifications",id:"abstract-specifications",level:2},{value:"Documentation generation",id:"documentation-generation",level:2},{value:"Supporting resources",id:"supporting-resources",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["This document describes the ",(0,s.jsx)(n.em,{children:"Move specification language (MSL)"}),", a subset of the ",(0,s.jsx)(n.a,{href:"/move/move-on-aptos",children:"Move"})," language that supports specification of the behavior of Move programs. MSL works together with the ",(0,s.jsx)(n.a,{href:"/move/prover/move-prover",children:"Move Prover"}),", a tool that can statically verify the correctness of MSL specifications against Move programs. In contrast to traditional testing, verification of MSL is exhaustive and holds for all possible inputs and global states of a ",(0,s.jsx)(n.a,{href:"/reference/glossary#move-module",children:"Move module"})," or ",(0,s.jsx)(n.a,{href:"/reference/glossary#transaction-or-move-script",children:"Move script"}),". At the same time, this verification of MSL is fast and automated enough that it can be used at a similar place in the developer workflow where tests are typically conducted (for example, for qualification of pull requests in continuous integration)."]}),"\n",(0,s.jsx)(n.p,{children:"While the Move programming language at this point is stable, the subset represented by MSL should be\nconsidered evolving. This has no impact on platform stability, since MSL is not running in\nproduction; yet MSL is used for offline quality assurance where it is continuously improved for\nevolving objectives."}),"\n",(0,s.jsxs)(n.p,{children:["This document describes the language only; see ",(0,s.jsx)(n.a,{href:"/move/prover/prover-guide",children:"Use the Move Prover"})," for instructions. The reader is expected to have basic knowledge of the Move language, as well as basic\nprinciples of pre- and post-condition specifications. (See for example the ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Design_by_contract",children:"Design by contract"}),"). For examples of specifications, we refer to\nthe ",(0,s.jsx)(n.a,{href:"https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/overview.md",children:"Aptos framework"})," documentation, which has specifications embedded."]}),"\n",(0,s.jsx)(n.h1,{id:"expressions",children:"Expressions"}),"\n",(0,s.jsx)(n.p,{children:"Expressions in MSL are a subset of Move program expressions plus a set of additional constructs, as\ndiscussed in the following sections."}),"\n",(0,s.jsx)(n.h2,{id:"type-system",children:"Type System"}),"\n",(0,s.jsx)(n.p,{children:"The type system of MSL is similar to that of Move, with the following differences:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["There are two types of encodings for integer types: ",(0,s.jsx)(n.code,{children:"num"})," and ",(0,s.jsx)(n.code,{children:"bv"})," (bit vector).\nIf an integer (either a constant or a variable) is not involved in any bitwise operations directly or indirectly,\nregardless of its type in Move (",(0,s.jsx)(n.code,{children:"u8"}),", ",(0,s.jsx)(n.code,{children:"u16"}),", ",(0,s.jsx)(n.code,{children:"u32"}),", ",(0,s.jsx)(n.code,{children:"u64"}),", ",(0,s.jsx)(n.code,{children:"u128"})," and ",(0,s.jsx)(n.code,{children:"u256"}),"), it is treated as the same type. In\nspecifications, this type is called ",(0,s.jsx)(n.code,{children:"num"}),", which is an arbitrary precision ",(0,s.jsx)(n.em,{children:"signed"})," integer type.\nWhen MSL refers to a Move name that represents an ",(0,s.jsx)(n.code,{children:"u8"})," or such, it will be automatically widened\nto ",(0,s.jsx)(n.code,{children:"num"}),". This allows writing MSL expressions like ",(0,s.jsx)(n.code,{children:"x + 1 <= MAX_U128"})," or ",(0,s.jsx)(n.code,{children:"x - y >= 0"})," without\nneeding to worry about overflow or underflow.\nDifferent from ",(0,s.jsx)(n.code,{children:"num"}),", ",(0,s.jsx)(n.code,{children:"bv"})," cannot and does not need to be explicitly used in specifications: if an integer is involved in bitwise operations such as ",(0,s.jsx)(n.code,{children:"&"}),", ",(0,s.jsx)(n.code,{children:"|"})," or ",(0,s.jsx)(n.code,{children:"^"}),", it will be automatically encoded as ",(0,s.jsx)(n.code,{children:"bv"}),"at the backend.\nMoreover, a ",(0,s.jsx)(n.code,{children:"bv"})," integer has a fixed precision, which is consistent with its precision in Move (",(0,s.jsx)(n.code,{children:"bv8"}),", ",(0,s.jsx)(n.code,{children:"bv16"}),", ",(0,s.jsx)(n.code,{children:"bv32"}),", ",(0,s.jsx)(n.code,{children:"bv64"}),", ",(0,s.jsx)(n.code,{children:"bv128"})," and ",(0,s.jsx)(n.code,{children:"bv256"}),").\nNote that, in general using ",(0,s.jsx)(n.code,{children:"bv"})," is not so efficient as ",(0,s.jsx)(n.code,{children:"num"})," in the ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Satisfiability_modulo_theories",children:"SMT"})," solver such as ",(0,s.jsx)(n.a,{href:"https://github.com/Z3Prover/z3",children:"Z3"}),". Consequently,\nthe Move Prover has some restrictions when using bitwise operations, which are stated in detail below."]}),"\n",(0,s.jsxs)(n.li,{children:["The Move types ",(0,s.jsx)(n.code,{children:"&T"}),", ",(0,s.jsx)(n.code,{children:"&mut T"}),", and ",(0,s.jsx)(n.code,{children:"T"})," are considered equivalent for MSL. Equality is interpreted\nas value equality. There is no need to worry about dereferencing a reference from the Move\nprogram: these are automatically dereferenced as needed. This simplification is possible because\nMSL cannot modify values from a Move program, and the program cannot directly reason about\nreference equality (which eliminates the need for doing so in MSL). (Note there is also a\nrestriction in expressiveness coming with this, namely\nfor ",(0,s.jsxs)(n.a,{href:"#expressiveness",children:["functions which return ",(0,s.jsx)(n.code,{children:"&mut T"})]}),". However, this is rarely hit in practice,\nand there are workarounds.)"]}),"\n",(0,s.jsxs)(n.li,{children:["There is the additional type ",(0,s.jsx)(n.code,{children:"type"}),", which is the type of all types. It can be used only in\nquantifiers."]}),"\n",(0,s.jsxs)(n.li,{children:["There is the additional type ",(0,s.jsx)(n.code,{children:"range"}),", which represents an integer range (and the notation ",(0,s.jsx)(n.code,{children:"n..m"})," to\ndenote a value)."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"naming",children:"Naming"}),"\n",(0,s.jsxs)(n.p,{children:["Name resolution in MSL works similar to the Move language. ",(0,s.jsx)(n.code,{children:"use"})," declarations can introduce aliases for\nimported names. MSL functions and variable names must start with a lowercase letter. Schema names\nare treated like types and must start with a capital letter. (",(0,s.jsx)(n.a,{href:"#schemas",children:"Schemas"})," are a named construct\ndiscussed later)."]}),"\n",(0,s.jsxs)(n.p,{children:["Move functions, MSL functions, Move types, and schemas all share the same namespace and are\ntherefore unambiguous if aliased via a Move ",(0,s.jsx)(n.code,{children:"use"})," clause. Because of the common name space, an MSL\nfunction cannot have the same name as a Move function. This is often handled via the convention to\nprefix MSL functions as in ",(0,s.jsx)(n.code,{children:"spec_has_access"})," when the related Move function is called ",(0,s.jsx)(n.code,{children:"has_access"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,s.jsxs)(n.p,{children:["All Move operators are supported in MSL, except ",(0,s.jsx)(n.code,{children:"&"}),", ",(0,s.jsx)(n.code,{children:"&mut"}),", and ",(0,s.jsx)(n.code,{children:"*"})," (dereference)."]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the existing operators, vector subscript ",(0,s.jsx)(n.code,{children:"v[i]"}),", slicing ",(0,s.jsx)(n.code,{children:"v[i..j]"}),", and range\nconstruction ",(0,s.jsx)(n.code,{children:"i..j"})," are supported (the type of integer ranges is a new builtin type called ",(0,s.jsx)(n.code,{children:"range"}),"). Moreover, boolean implication ",(0,s.jsx)(n.code,{children:"p ==> q"})," is supported as a more intuitive form than ",(0,s.jsx)(n.code,{children:"!p || q"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"function-calls",children:"Function calls"}),"\n",(0,s.jsxs)(n.p,{children:["In MSL expressions, functions can be called like in Move. However, the callee must either be\nan ",(0,s.jsx)(n.a,{href:"#helper-functions",children:"MSL helper function"})," or a ",(0,s.jsx)(n.strong,{children:"pure"})," Move function."]}),"\n",(0,s.jsx)(n.p,{children:"Move functions are considered pure if they do not modify global state and do not use Move expression\nfeatures that are not supported in MSL expressions (as defined in this document)."}),"\n",(0,s.jsxs)(n.p,{children:["There is one extension. If a Move function definition contains a direct ",(0,s.jsx)(n.code,{children:"assert"}),", this will be\nignored when it is called from an MSL expression, and the function will be considered pure. For\nexample:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun get(addr: address): &T { assert(exists<T>(addr), ERROR_CODE); borrow_global<T>(addr) }\n"})}),"\n",(0,s.jsx)(n.p,{children:"This function is pure and can be called from an MSL expression. The assertion will be ignored, and\nthe function will be interpreted as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec fun get(addr: address): T { global<T>(addr) }\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is justified by that MSL having ",(0,s.jsx)(n.a,{href:"#partial-semantics",children:(0,s.jsx)(n.em,{children:"partial semantics"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"statements",children:"Statements"}),"\n",(0,s.jsxs)(n.p,{children:["Limited sequencing of the form ",(0,s.jsx)(n.code,{children:"{ let x = foo(); x + x }"})," is supported, as well as if-then-else.\nOther statement forms of the Move language are not supported."]}),"\n",(0,s.jsx)(n.h2,{id:"pack-and-unpack",children:"Pack and unpack"}),"\n",(0,s.jsxs)(n.p,{children:["Pack expressions are supported. Unpack expressions are currently ",(0,s.jsx)(n.em,{children:"not"})," supported."]}),"\n",(0,s.jsx)(n.h2,{id:"quantifiers",children:"Quantifiers"}),"\n",(0,s.jsx)(n.p,{children:"Universal and existential quantification is supported. The general form is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"forall <binding>, ..., <binding> [ where <exp> ] : <exp>\nexists <binding>, ..., <binding> [ where <exp> ] : <exp>\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Bindings can either be of the form ",(0,s.jsx)(n.code,{children:"name: <type>"})," or ",(0,s.jsx)(n.code,{children:"name in <exp>"}),". For the second form, the\nexpression must either be a ",(0,s.jsx)(n.code,{children:"range"})," or a vector."]}),"\n",(0,s.jsxs)(n.li,{children:["The optional constraint ",(0,s.jsx)(n.code,{children:"where <exp>"})," allows to restrict the quantified range. ",(0,s.jsx)(n.code,{children:"forall x: T where p: q"}),"\nis equivalent to ",(0,s.jsx)(n.code,{children:"forall x: T : p ==> q"})," and ",(0,s.jsx)(n.code,{children:"exists x: T where p: q"})," is equivalent to ",(0,s.jsx)(n.code,{children:"exists x: T : p && q"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Notice that it is possible to quantify over types. For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"forall t: type, addr: address where exists<R<t>>(addr): exists<T<t>>(addr)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"choice-operator",children:"Choice operator"}),"\n",(0,s.jsx)(n.p,{children:"The choice operator allows selecting a value that satisfies a predicate:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"choose a: address where exists<R>(a) && global<R>(a).value > 0\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the predicate is not satisfiable, the result of the choice will be undetermined. (See ",(0,s.jsx)(n.a,{href:"#partial-semantics",children:"partial semantics"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["The choice also comes in a form to select the ",(0,s.jsx)(n.em,{children:"minimal"})," value from a set of integers, as in:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"choose min i: num where in_range(v, i) && v[i] == 2\n"})}),"\n",(0,s.jsx)(n.h2,{id:"cast-operator",children:"Cast operator"}),"\n",(0,s.jsxs)(n.p,{children:["In the specification language, we can use the same syntax ",(0,s.jsx)(n.code,{children:"(e as T)"})," to cast an expression ",(0,s.jsx)(n.code,{children:"e"})," with one integer type to ",(0,s.jsx)(n.code,{children:"T"}),", an integer type of another size."]}),"\n",(0,s.jsx)(n.h2,{id:"shift-operator",children:"Shift operator"}),"\n",(0,s.jsxs)(n.p,{children:["Shift operators ",(0,s.jsx)(n.code,{children:"<<"})," and ",(0,s.jsx)(n.code,{children:">>"})," are supported in the specification language, and both of them have the same semantics with the Move language. As for abort, if a value ",(0,s.jsx)(n.code,{children:"v"})," has width ",(0,s.jsx)(n.code,{children:"n"}),", then ",(0,s.jsx)(n.code,{children:"v << m"})," or ",(0,s.jsx)(n.code,{children:"v >> m"})," will abort if ",(0,s.jsx)(n.code,{children:"m >= n"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"bitwise-operators",children:"Bitwise operators"}),"\n",(0,s.jsxs)(n.p,{children:["Move programs using bitwise operators ",(0,s.jsx)(n.code,{children:"&"}),", ",(0,s.jsx)(n.code,{children:"|"})," and ",(0,s.jsx)(n.code,{children:"^"})," can be verified in the prover, and these operators are also supported in the specification language.\nDue to encoding and efficiency issues, using bitwise operators has more caveats:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Integers involved in bitwise operations are encoded as ",(0,s.jsx)(n.code,{children:"bv"})," types at the backend, and two encodings of integers are not compatible. For instance, if a variable ",(0,s.jsx)(n.code,{children:"v"})," is involved in a bitwise operation such as ",(0,s.jsx)(n.code,{children:"v & 2"})," or ",(0,s.jsx)(n.code,{children:"v = a ^ b"}),", then when it is used in an arithmetic operation ",(0,s.jsx)(n.code,{children:"v * w"})," or a shift operation ",(0,s.jsx)(n.code,{children:"v << w"}),", ",(0,s.jsx)(n.code,{children:"w"})," will be implicitly cast to a ",(0,s.jsx)(n.code,{children:"bv"})," type in the Move program.\nHowever, the specification language does not support implicit type cast so users must explicitly use the built-in function ",(0,s.jsx)(n.code,{children:"int2bv"})," in the specification: ",(0,s.jsx)(n.code,{children:"v << int2bv(w)"}),".\nNot that since each ",(0,s.jsx)(n.code,{children:"bv"})," type has a fixed length (from 8 to 256), values with type ",(0,s.jsx)(n.code,{children:"num"})," cannot be converted into ",(0,s.jsx)(n.code,{children:"bv"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Verification of ",(0,s.jsx)(n.code,{children:"bv"})," types is not efficient and may lead to timeout. As a result, users may prefer isolating bitwise operations from other operations and not using ",(0,s.jsx)(n.code,{children:"int2bv"})," if possible. Moreover, users need to use pragmas to explicitly specify which integer-typed function arguments or struct fields will be used in bitwise computations:"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:'    struct C has drop {\n        a: u64,\n        b: u64\n    }\n    spec C {\n        // b, the second field of C, will be of bv type\n        pragma bv=b"1";\n    }\n    public fun foo_generic<T>(i: T): T {\n      i\n    }\n\n    spec foo_generic {\n     // The first parameter will be of bv type if T is instantiated as a number type\n      pragma bv=b"0";\n     // The first return value will be of bv type if T is instantiated as a number type\n      pragma bv_ret=b"0";\n    }\n\n    public fun test(i: C): u64 {\n      let x1 = foo_generic(C.b);\n      x1 ^ x1\n    }\n\n    spec test {\n      // Explicit type cast is mandatory for generating correct boogie program\n      ensures result == (0 as u64);\n    }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that if arguments or fields of a generic function or struct are specified with ",(0,s.jsx)(n.code,{children:"bv"})," types,\nthey will be of ",(0,s.jsx)(n.code,{children:"bv"})," types in all instances of the function or the struct when the instantiated type is an integer type."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Values with integer types in vectors and tables can be encoded as ",(0,s.jsx)(n.code,{children:"bv"})," types; indices and keys in tables cannot be ",(0,s.jsx)(n.code,{children:"bv"})," types for now. Using other types will lead to internal errors."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"built-in-functions",children:"Built-in functions"}),"\n",(0,s.jsx)(n.p,{children:"MSL supports a number of built-in constants and functions. Most of them are not available in the Move\nlanguage:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MAX_U8: num"}),", ",(0,s.jsx)(n.code,{children:"MAX_U64: num"}),", ",(0,s.jsx)(n.code,{children:"MAX_U128: num"})," returns the maximum value of the corresponding\ntype."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"exists<T>(address): bool"})," returns true if the resource T exists at address."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"global<T>(address): T"})," returns the resource value at address."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"len<T>(vector<T>): num"})," returns the length of the vector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"update<T>(vector<T>, num, T>): vector<T>"})," returns a new vector with the element replaced at the\ngiven index."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"vec<T>(): vector<T>"})," returns an empty vector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"vec<T>(x): vector<T>"})," returns a singleton vector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"concat<T>(vector<T>, vector<T>): vector<T>"})," returns the concatenation of the parameters."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"contains<T>(vector<T>, T): bool"})," returns true if element is in vector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"index_of<T>(vector<T>, T): num"})," returns the index of the element in the vector, or the length of\nthe vector if it does not contain it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"range<T>(vector<T>): range"})," returns the index range of the vector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"in_range<T>(vector<T>, num): bool"})," returns true if the number is in the index range of the\nvector."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"in_range<T>(range, num): bool"})," returns true if the number is in the range."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"update_field(S, F, T): S"})," updates a field in a struct, preserving the values of other fields,\nwhere ",(0,s.jsx)(n.code,{children:"S"})," is some struct, ",(0,s.jsx)(n.code,{children:"F"})," the name of a field in ",(0,s.jsx)(n.code,{children:"S"}),", and ",(0,s.jsx)(n.code,{children:"T"})," a value for this field."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"old(T): T"})," delivers the value of the passed argument at point of entry into a Move function. This\nis allowed in\n",(0,s.jsx)(n.code,{children:"ensures"})," post-conditions,\ninline spec blocks (with additional restrictions), and\ncertain forms of invariants, as discussed later."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TRACE(T): T"})," is semantically the identity function and causes visualization of the argument's\nvalue in error messages created by the prover."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"int2bv(v)"})," explicitly converts an integer ",(0,s.jsx)(n.code,{children:"v"})," into its ",(0,s.jsx)(n.code,{children:"bv"})," representation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"bv2int(b)"})," explicitly converts a 'bv' integer 'b' into the ",(0,s.jsx)(n.code,{children:"num"})," representation. However, it is not encouraged to use it due to efficiency issue."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Built-in functions live in an unnamed outer scope of a module. If the module defines a function ",(0,s.jsx)(n.code,{children:"len"}),",\nthen this definition will shadow that of the according built-in function. To access the built-in\nfunction in such a situation, one can use the notation ",(0,s.jsx)(n.code,{children:"::len(v)"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"partial-semantics",children:"Partial semantics"}),"\n",(0,s.jsx)(n.p,{children:"In MSL, expressions have partial semantics. This is in contrast to Move program expressions, which\nhave total semantics, since they either deliver a value or abort."}),"\n",(0,s.jsxs)(n.p,{children:["An expression ",(0,s.jsx)(n.code,{children:"e[X]"})," that depends on some variables ",(0,s.jsx)(n.code,{children:"X"})," may have a known interpretation for\nsome assignments to variables in ",(0,s.jsx)(n.code,{children:"X"})," but is unknown for others. An unknown interpretation for a\nsub-expression causes no issue if its value is not needed for the overall expression result.\nTherefore, it does not matter if we say ",(0,s.jsx)(n.code,{children:"y != 0 && x / y > 0"}),"\nor ",(0,s.jsx)(n.code,{children:"x / y > 0 && y != 0"}),": boolean operators are commutative."]}),"\n",(0,s.jsxs)(n.p,{children:["This basic principle inherits to higher-level language constructs. For example, in specifications,\nit does not matter in which order conditions are supplied: ",(0,s.jsx)(n.code,{children:"aborts_if y != 0; ensures result == x / y;"})," is the same as\n",(0,s.jsx)(n.code,{children:"ensures result == x / y; aborts_if y != 0;"}),". Also, ",(0,s.jsx)(n.code,{children:"aborts_if P; aborts_if Q;"})," is the same\nas ",(0,s.jsx)(n.code,{children:"aborts_if Q || P"}),"\n."]}),"\n",(0,s.jsxs)(n.p,{children:["Moreover, the principle of partial semantics is inherited to ",(0,s.jsx)(n.a,{href:"#helper-functions",children:"specification helper functions"}),", which behave transparently. Specifically, inlining those functions is equivalent to calling them (call-by-expression parameter passing semantics)."]}),"\n",(0,s.jsx)(n.h1,{id:"specifications",children:"Specifications"}),"\n",(0,s.jsxs)(n.p,{children:["Specifications are contained in so-called ",(0,s.jsx)(n.em,{children:"specification blocks"})," (abbreviated ",(0,s.jsx)(n.strong,{children:"spec block"}),") that\ncan appear as module members and inside Move functions. The various types of spec blocks are shown\nbelow, and will be discussed in subsequent sections."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module addr::M {\n    struct Counter has key {\n        value: u8,\n    }\n\n    public fun increment(a: address) acquires Counter {\n        let r = borrow_global_mut<Counter>(a);\n        spec {\n            // spec block targeting this code position\n            ...\n        };\n        r.value = r.value + 1;\n    }\n\n    spec increment {\n        // spec block targeting function increment\n        ...\n    }\n\n    spec Counter {\n        // spec block targeting struct Counter\n        ...\n    }\n\n    spec schema Schema {\n        // spec block declaring a schema\n        ...\n    }\n\n    spec fun f(x: num): num {\n        // spec block declaring a helper function\n        ...\n    }\n\n    spec module {\n        // spec block targeting the whole module\n        ...\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apart from spec blocks inside Move functions, the textual position of spec block is irrelevant. Also,\na spec block for a struct, function, or module can be repeated multiple times, accumulating the\ncontent."}),"\n",(0,s.jsx)(n.h2,{id:"separating-specifications",children:"Separating specifications"}),"\n",(0,s.jsx)(n.p,{children:'Instead of putting specifications into the same module as the regular Move definitions, one can also\nput them into a separate "specification" module, which can live in the same or a different file:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module addr::M {\n    ...\n}\nspec addr::M {\n    spec increment { .. }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The syntax of a specification module is the same as for a regular module; however, Move functions\nand structures are not allowed."}),"\n",(0,s.jsx)(n.p,{children:"A specification module must be compiled together with the Move module it is targeting and cannot be\ncompiled and verified standalone."}),"\n",(0,s.jsx)(n.p,{children:"In case Move definitions are far apart (e.g. in different files), it is possible to augment the\nspecification of a Move function with a signature of this function to give sufficient context to\nunderstand the specification. This syntax is optionally enabled in regular and in specification\nmodules:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"public fun increment(a: address) acquires Counter { .. }\n...\nspec increment(a: address) { .. }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"pragmas-and-properties",children:"Pragmas and properties"}),"\n",(0,s.jsx)(n.p,{children:"Pragmas and properties are a generic mechanism to influence interpretation of specifications. They\nare also an extension point to experiment with new concepts before they become part of the mainstream\nsyntax. Here we give a brief introduction into their general syntax; individual instances are\ndiscussed later."}),"\n",(0,s.jsx)(n.p,{children:"The general form of a pragma is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec .. {\n    pragma <name> = <literal>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The general form of a property is:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec .. {\n    <directive> [<name> = <literal>] <content>; // ensures, aborts_if, include, etc..\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"<literal>"})," can be any value supported by MSL (or the Move language). A value assignment can\nalso be omitted, in which case a default is used. For example, it is common to use ",(0,s.jsx)(n.code,{children:"pragma option;"}),"\nas a shortcut for ",(0,s.jsx)(n.code,{children:"pragma option = true;"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Instead of a single pragma or property, a list can also be provided, as in ",(0,s.jsx)(n.code,{children:"invariant [global, isolated] P"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"pragma-inheritance",children:"Pragma inheritance"}),"\n",(0,s.jsx)(n.p,{children:"A pragma in a module spec block sets a value that applies to all other spec blocks in the module. A\npragma in a function or struct spec block can override this value for the function or struct.\nFurthermore, the default value of some pragmas can be defined via the prover configuration."}),"\n",(0,s.jsxs)(n.p,{children:["As an example, we look at the ",(0,s.jsx)(n.code,{children:"verify"})," pragma. This pragma is used to turn verification on or off."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec module {\n    pragma verify = false; // By default, do not verify specs in this module ...\n}\n\nspec increment {\n    pragma verify = true; // ... but do verify this function.\n    ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"general-pragmas-and-properties",children:"General pragmas and properties"}),"\n",(0,s.jsx)(n.p,{children:"A number of pragmas control general behavior of verification. Those are listed in the table below."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"verify"})}),(0,s.jsx)(n.td,{children:"Turns on or off verification."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"intrinsic"})}),(0,s.jsx)(n.td,{children:"Marks a function to skip the Move implementation and use a prover native implementation. This makes a function behave like a native function even if it not so in Move."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"timeout"})}),(0,s.jsx)(n.td,{children:"Sets a timeout (in seconds) for function or module. Overrides the timeout provided by command line flags."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"verify_duration_estimate"})}),(0,s.jsxs)(n.td,{children:["Sets an estimate (in seconds) for how long the verification of function takes. If the configured ",(0,s.jsx)(n.code,{children:"timeout"})," is less than this value, verification will be skipped."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"seed"})}),(0,s.jsx)(n.td,{children:"Sets a random seed for function or module. Overrides the seed provided by command line flags."})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"The following properties control general behavior of verification:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Name"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[deactivated]"})}),(0,s.jsx)(n.td,{children:"Excludes the associated condition from verification."})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"pre-and-post-state",children:"Pre and post state"}),"\n",(0,s.jsxs)(n.p,{children:["Multiple conditions in spec blocks work with a ",(0,s.jsx)(n.em,{children:"pre"})," and ",(0,s.jsx)(n.em,{children:"post"})," state, relating them to each other.\nFunction specifications are one example of this: in the ",(0,s.jsx)(n.code,{children:"ensures P"})," condition, the pre-state (at\nfunction entry) and the post-state (at function exit) are related via the predicate ",(0,s.jsx)(n.code,{children:"P"}),". However,\nthe concept is more general and also applied for invariants, where the pre-state is before and\npost-state after a global update."]}),"\n",(0,s.jsxs)(n.p,{children:["In contexts where a pre/post-state is active, expressions are evaluated implicitly in the\npost-state. To evaluate an expression in a pre-state, one uses the built-in function ",(0,s.jsx)(n.code,{children:"old(exp)"}),",\nwhich evaluates its parameter in the pre-state and returns its value. It is important to understand\nthat every sub-expression in ",(0,s.jsx)(n.code,{children:"exp"})," is computed in the pre-state as well, including calls to helper\nfunctions."]}),"\n",(0,s.jsxs)(n.p,{children:["The 'state' in question here consists of assignments to global resource memory, as well as to any\nparameters of the function of type ",(0,s.jsx)(n.code,{children:"&mut T"}),". Examples:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun increment(counter: &mut u64) { *counter = *counter + 1 }\nspec increment {\n   ensures counter == old(counter) + 1;\n}\n\nfun increment_R(addr: address) {\n    let r =  borrow_global_mut<R>(addr);\n    r.value = r.value + 1;\n}\nspec increment_R {\n    ensures global<R>(addr).value == old(global<R>(addr).value) + 1;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"helper-functions",children:"Helper functions"}),"\n",(0,s.jsx)(n.p,{children:"MSL allows defining helper functions. Those functions can then be used in expressions."}),"\n",(0,s.jsx)(n.p,{children:"Helper functions are defined using the following syntax:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec fun exists_balance<Currency>(a: address): bool { exists<Balance<Currency>>(a) }\n"})}),"\n",(0,s.jsx)(n.p,{children:"As seen in the example, helper functions can be generic. Moreover, they can access global state."}),"\n",(0,s.jsxs)(n.p,{children:["Definitions of helper functions are neutral regarding whether they apply to\na ",(0,s.jsx)(n.a,{href:"#pre-and-post-state",children:"pre- or post-state"}),". They are evaluated in the currently active state. For\ninstance, in order to see whether a balance existed in the pre-state, one\nuses ",(0,s.jsx)(n.code,{children:"old(exists_balance<Currency>(a))"}),". Consequently, the expression ",(0,s.jsx)(n.code,{children:"old(..)"})," is not allowed\nwithin the definition of a helper function."]}),"\n",(0,s.jsxs)(n.p,{children:["Helper functions are partial functions; see the discussion of ",(0,s.jsx)(n.a,{href:"#partial-semantics",children:"partial semantics"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"uninterpreted-functions",children:"Uninterpreted functions"}),"\n",(0,s.jsxs)(n.p,{children:["A helper function can be defined as ",(0,s.jsx)(n.strong,{children:"uninterpreted"})," by simply omitting its body:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec fun something(x: num): num;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["An uninterpreted function is one of the prover is allowed to assign some arbitrary meaning to, as long\nas it is consistent within a given verification context. Uninterpreted functions are a useful tool\nfor abstraction in specifications (see also ",(0,s.jsx)(n.a,{href:"#abstract-specifications",children:"abstract specifications"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"axioms",children:"Axioms"}),"\n",(0,s.jsxs)(n.p,{children:["The meaning of helper functions can be further constrained by using ",(0,s.jsx)(n.strong,{children:"axioms"}),". Currently, axioms\nmust be contained in module spec blocks:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec module {\n    axiom forall x: num: something(x) == x + 1;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Axioms should be used with care as they can introduce unsoundness in the specification logic via\ncontradicting assumptions. The Move Prover supports a smoke test for detecting unsoundness via\nthe ",(0,s.jsx)(n.code,{children:"--check-inconsistency"})," flag."]}),"\n",(0,s.jsx)(n.h2,{id:"let-bindings",children:"Let bindings"}),"\n",(0,s.jsx)(n.p,{children:"A spec block can contain let bindings that introduce names for expressions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun get_R(account: signer): R { ... }\nspec get_R {\n    let addr = signer::spec_address_of(account);\n    aborts_if addr != ROOT;\n    ensures result == global<R>(addr);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In a spec block that has a pre-state and post-state (like a function specification), the ",(0,s.jsx)(n.code,{children:"let name = e"}),"\nform will evaluate ",(0,s.jsx)(n.code,{children:"e"})," in the pre-state. In order to evaluate an expression in the post-state, use ",(0,s.jsx)(n.code,{children:"let post name = e"}),". In the rhs expression of this form, one can use ",(0,s.jsx)(n.code,{children:"old(..)"})," to refer to the\npre-state."]}),"\n",(0,s.jsx)(n.h2,{id:"aborts_if-condition",children:"Aborts_if condition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"aborts_if"})," condition is a spec block member that can appear only in a function context. It\nspecifies conditions under which the function aborts."]}),"\n",(0,s.jsxs)(n.p,{children:["In the following example, we specify that the function ",(0,s.jsx)(n.code,{children:"increment"})," aborts if the ",(0,s.jsx)(n.code,{children:"Counter"})," resource\ndoes not exist at address ",(0,s.jsx)(n.code,{children:"a"})," (recall that ",(0,s.jsx)(n.code,{children:"a"})," is the name of the parameter of ",(0,s.jsx)(n.code,{children:"increment"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    aborts_if !exists<Counter>(a);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If a function has more than one ",(0,s.jsx)(n.code,{children:"aborts_if"})," condition, those conditions are or-ed with each other.\nThe evaluation of the combined aborts condition (or-ed from each individual condition) depends on\nthe value of the pragma ",(0,s.jsx)(n.code,{children:"aborts_if_is_partial"}),". If this value is false (the default), the function\naborts ",(0,s.jsx)(n.em,{children:"if and only if"})," the combined aborts condition is true. In this case, the above aborts\nspecification for ",(0,s.jsx)(n.code,{children:"increment"})," will lead to a verification error, since there are additional\nsituations where ",(0,s.jsx)(n.code,{children:"increment"})," can abort, namely if incrementing ",(0,s.jsx)(n.code,{children:"Counter.value"})," would lead to an\noverflow. To fix this, the specification can be completed like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    pragma aborts_if_is_partial = false; // This is the default, but added here for illustration.\n    aborts_if !exists<Counter>(a);\n    aborts_if global<Counter>(a).value == 255;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the value of ",(0,s.jsx)(n.code,{children:"aborts_if_is_partial"})," is true, the combined aborts condition (the or-ed individual\nconditions) only ",(0,s.jsx)(n.em,{children:"implies"})," that the function aborts. Formally, if ",(0,s.jsx)(n.code,{children:"A"})," is the combined aborts condition, then\nwith ",(0,s.jsx)(n.code,{children:"aborts_if_is_partial = true"}),", we have ",(0,s.jsx)(n.code,{children:"A ==> function_aborts"}),"; otherwise we have\n",(0,s.jsx)(n.code,{children:"A <==> function_aborts"}),". Therefore, the following does verify:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    pragma aborts_if_is_partial = true;\n    aborts_if !exists<Counter>(a);\n}\n"})}),"\n",(0,s.jsx)("a",{name:"risk-aborts-if-is-partial"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Note that there is a certain risk in setting ",(0,s.jsx)(n.code,{children:"aborts_if_is_partial"})," to true, and best practice is to avoid it in specifications of public functions and Move scripts once those are considered finalized. This is because changing the code after finalization of the spec can add new (non-trivial, undesired) abort situations the original specification did not anticipate yet will nevertheless silently pass verification."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If no aborts condition is specified for a function, abort behavior is unspecified. The function may\nor may not abort, and verification will not raise any errors, whether ",(0,s.jsx)(n.code,{children:"aborts_if_is_partial"})," is set\nor not. In order to state that a function never aborts, use ",(0,s.jsx)(n.code,{children:"aborts_if false"}),". One can use the\npragma ",(0,s.jsx)(n.code,{children:"aborts_if_is_strict"})," to change this behavior; this is equivalent to an ",(0,s.jsx)(n.code,{children:"aborts_if false"})," being added to each function that does not have an explicit ",(0,s.jsx)(n.code,{children:"aborts_if"})," clause."]}),"\n",(0,s.jsx)(n.h3,{id:"aborts_if-condition-with-code",children:"Aborts_if condition with code"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"aborts_if"})," condition can be augmented with code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun get_value(addr: address): u64 {\n    aborts(exists<Counter>(addr), 3);\n    borrow_global<Counter>(addr).value\n}\nspec get_value {\n    aborts_if !exists<Counter>(addr) with 3;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It is a verification error if the above function does not abort with code ",(0,s.jsx)(n.code,{children:"3"})," under the given\ncondition."]}),"\n",(0,s.jsxs)(n.p,{children:["In order to specify a direct VM abort, one can use the special constant ",(0,s.jsx)(n.code,{children:"EXECUTION_FAILURE"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun get(addr: address): &Counter acquires Counter {\n    borrow_global<Counter>(addr)\n}\nspec get {\n    aborts_if !exists<Counter>(addr) with EXECUTION_FAILURE;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This same constant can be used for all other VM failures (division by zero, overflow, etc.)."}),"\n",(0,s.jsx)(n.h2,{id:"aborts_with-condition",children:"Aborts_with condition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"aborts_with"})," condition allows specifying with which codes a function can abort, independent\nunder which condition. It is similar to a 'throws' clause in languages like Java."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun get_one_off(addr: address): u64 {\n    aborts(exists<Counter>(addr), 3);\n    borrow_global<Counter>(addr).value - 1\n}\nspec get_one_off {\n    aborts_with 3, EXECUTION_FAILURE;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"If the function aborts with any other or none of the specified codes, a verification error will be\nproduced."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"aborts_with"})," condition can be combined with ",(0,s.jsx)(n.code,{children:"aborts_if"})," conditions. In this case, the ",(0,s.jsx)(n.code,{children:"aborts_with"}),"\nspecifies any other codes with which the function may abort, in addition to the ones given in the ",(0,s.jsx)(n.code,{children:"aborts_if"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec get_one_off {\n    aborts_if !exists<Counter>(addr) with 3;\n    aborts_with EXECUTION_FAILURE;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If this is not wanted, and the ",(0,s.jsx)(n.code,{children:"aborts_with"})," should be independent of ",(0,s.jsx)(n.code,{children:"aborts_if"}),", one can use the\nproperty ",(0,s.jsx)(n.code,{children:"[check]"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec get_one_off {\n    aborts_if !exists<Counter>(addr) with 3;\n    aborts_if global<Counter>(addr) == 0 with EXECUTION_FAILURE;\n\n    aborts_with [check] 3, EXECUTION_FAILURE;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"requires-condition",children:"Requires condition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"requires"})," condition is a spec block member that postulates a pre-condition for a function. The\nMove Prover will produce verification errors for functions that are called with violating\npre-conditions."]}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"requires"})," is different from an ",(0,s.jsx)(n.code,{children:"aborts_if"}),": in the latter case, the function can be called, and\nany aborts it produces will be propagated to the caller context. In the ",(0,s.jsx)(n.code,{children:"requires"})," case, the Move Prover\nwill not allow the function to be called in the first place. Nevertheless, the function can ",(0,s.jsx)(n.em,{children:"still\nbe called at runtime"})," if verification is skipped. Because of this, ",(0,s.jsx)(n.code,{children:"requires"})," are rare in Move\nspecifications, and ",(0,s.jsx)(n.code,{children:"aborts_if"})," are more common. Specifically, ",(0,s.jsx)(n.code,{children:"requires"})," should be avoided for public APIs."]}),"\n",(0,s.jsxs)(n.p,{children:["An example of ",(0,s.jsx)(n.code,{children:"requires"})," is:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    requires global<Counter>(a).value < 255;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"ensures-condition",children:"Ensures condition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ensures"})," condition postulates a post-condition for a function that must be satisfied when the\nfunction terminates successfully (i.e. does not abort). The Move Prover will verify each ",(0,s.jsx)(n.code,{children:"ensures"})," to\nthis end."]}),"\n",(0,s.jsxs)(n.p,{children:["An example for the ",(0,s.jsx)(n.code,{children:"ensures"})," condition is the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    ensures global<Counter>(a) == old(global<Counter>(a)) + 1;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Within the expression for the ",(0,s.jsx)(n.code,{children:"ensures"})," condition, one can use the ",(0,s.jsx)(n.code,{children:"old"})," function, as discussed in\n",(0,s.jsx)(n.a,{href:"#pre-and-post-state",children:"Pre and post state"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"modifies-condition",children:"Modifies condition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"modifies"})," condition is used to provide permissions to a function to modify global storage. The\nannotation itself comprises a list of global access expressions. It is specifically used together\nwith ",(0,s.jsx)(n.a,{href:"#opaque-specifications",children:"opaque function specifications"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"struct S has key {\n    x: u64\n}\n\nfun mutate_at(addr: address) acquires S {\n    let s = borrow_global_mut<S>(addr);\n    s.x = 2;\n}\nspec mutate_at {\n    pragma opaque;\n    modifies global<S>(addr);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In general, a global access expression has the form ",(0,s.jsx)(n.code,{children:"global<type_expr>(address_expr)"}),". The\naddress-valued expression is evaluated in the pre-state of the annotated function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun read_at(addr: address): u64 acquires S {\n    let s = borrow_global<S>(addr);\n    s.x\n}\n\nfun mutate_S_test(addr1: address, addr2: address): bool acquires T {\n    assert(addr1 != addr2, 43);\n    let x = read_at(addr2);\n    mutate_at(addr1); // Note we are mutating a different address than the one read before and after\n    x == read_at(addr2)\n}\nspec mutate_S_test {\n    aborts_if addr1 == addr2;\n    ensures result == true;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the function ",(0,s.jsx)(n.code,{children:"mutate_S_test"}),", the assertion in the spec block is expected to hold. A benefit of\nthe modifies specification on ",(0,s.jsx)(n.code,{children:"mutate_at"})," is that this assertion can be proved whether ",(0,s.jsx)(n.code,{children:"mutate_at"})," is inlined."]}),"\n",(0,s.jsxs)(n.p,{children:["If the modifies annotation is omitted on a function, then that function is deemed to have all\npossible permissions for those resources it may modify during its execution. The set of all\nresources that may be modified by a function is obtained via an interprocedural analysis of the\ncode. In the example above, ",(0,s.jsx)(n.code,{children:"mutate_S_test"})," does not have a modifies specification and modifies\nresource ",(0,s.jsx)(n.code,{children:"S"})," via the call to ",(0,s.jsx)(n.code,{children:"mutate_at"}),". Therefore, it is considered to have modified ",(0,s.jsx)(n.code,{children:"S"})," at any\npossible address. Instead, if the programmer adds ",(0,s.jsx)(n.code,{children:"modifies global<S>(addr1)"}),"\nto the specification of ",(0,s.jsx)(n.code,{children:"mutate_S_test"}),", then the call to ",(0,s.jsx)(n.code,{children:"mutate_at"})," is checked to make sure that\nmodify permissions granted to ",(0,s.jsx)(n.code,{children:"mutate_S_test"})," cover the permissions it grants to ",(0,s.jsx)(n.code,{children:"mutate_at"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"invariant-condition",children:"Invariant condition"}),"\n",(0,s.jsx)(n.p,{children:"The invariant condition can be applied on structs and on global level."}),"\n",(0,s.jsx)(n.h3,{id:"function-invariants",children:"Function invariants"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"invariant"})," condition on a function is simply a shortcut for a ",(0,s.jsx)(n.code,{children:"requires"})," and ",(0,s.jsx)(n.code,{children:"ensures"})," with the\nsame predicate."]}),"\n",(0,s.jsx)(n.p,{children:"Thus, the following spec block:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    invariant global<Counter>(a).value < 128;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"... is equivalent to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    requires global<Counter>(a).value < 128;\n    ensures global<Counter>(a).value < 128;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"struct-invariants",children:"Struct invariants"}),"\n",(0,s.jsxs)(n.p,{children:["When the ",(0,s.jsx)(n.code,{children:"invariant"})," condition is applied to a struct, it expresses a well-formedness property of\nthe struct data. Any instance of this struct that is currently not mutated will satisfy this\nproperty (with exceptions as outlined below)."]}),"\n",(0,s.jsx)(n.p,{children:"For example, we can postulate an invariant on our counter that it never must exceed the value of\n127:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec Counter {\n    invariant value < 128;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A struct invariant is checked by the Move Prover whenever the struct value is constructed (packed). While\nthe struct is mutated (e.g. via a ",(0,s.jsx)(n.code,{children:"&mut Counter"}),") the invariant does ",(0,s.jsx)(n.em,{children:"not"})," hold (but see exception\nbelow). In general, we consider mutation as an implicit unpack, and end of mutation as a pack."]}),"\n",(0,s.jsx)(n.p,{children:"The Move language semantics unambiguously identifies the point when mutation ends and starts. This\nfollows from the borrow semantics of Move and includes mutation via an enclosing struct.\n(The mutation of an inner struct ends when the mutation of the root struct where mutation started\nends.)"}),"\n",(0,s.jsxs)(n.p,{children:["There is one exception to this rule. When a mutable reference to a struct declared in module M is\npassed into a ",(0,s.jsx)(n.em,{children:"public"})," function of M which does by itself ",(0,s.jsx)(n.em,{children:"not"}),' return any other mutable reference (which could be borrowed from the input parameter), we treat this parameter as "packed". That means, on function entry, we will unpack it and on function exit we will pack again, enforcing the invariant. This reflects that in Move, struct data can be mutated only within the module that declares the struct; so for an outside caller of the public function, the mutable reference can actually not be mutated unless by calling public functions of module M again. It is a significant simplification of the verification problem to exploit this in the semantics.']}),"\n",(0,s.jsx)(n.h3,{id:"global-invariants",children:"Global invariants"}),"\n",(0,s.jsxs)(n.p,{children:["A global invariant appears as a member of module. It can express a condition over the global state\nof the Move program, as represented by resources stored in memory. For example, the below invariant\nstates that a ",(0,s.jsx)(n.code,{children:"Counter"})," resource stored at any given address can never be zero:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module addr::M {\n    invariant forall a: addr where exists<Counter>(a): global<Counter>(a).value > 0;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"A global invariant is assumed to hold when data is read from the global state, and is asserted (and\nmay fail to verify) at the moment the state is updated. For example, the below function will never abort with arithmetic underflow because the counter value is always greater than zero; however, it will create a verification error since the counter can drop to zero:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun decrement_ad(addr: address) acquires Counter {\n    let counter = borrow_global_mut<Counter>(addr);\n    let new_value = counter.value - 1;   // Will not abort because counter.value > 0\n    *counter.value = new_value;          // Fails verification since value can drop to zero\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"disabling-invariants",children:"Disabling invariants"}),"\n",(0,s.jsx)(n.p,{children:"There are times when a global invariant holds almost everywhere, except for a brief interval inside a function. In current Move code, this often occurs when something (e.g. an account) is being set up and\nseveral structs are published together. Almost everywhere, an invariant holds that all the structs are published or none of them are. But the code that publishes the structs must do so sequentially. While the structs are being published, there will be a point where some are published and others are not."}),"\n",(0,s.jsx)(n.p,{children:"In order to verify invariants that hold except during small regions, there is a feature to allow users to disable invariants temporarily. Consider the following code fragment:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fn setup() {\n    publish1();\n    publish2();\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"publish1"})," and ",(0,s.jsx)(n.code,{children:"publish2"})," publish two different structs, ",(0,s.jsx)(n.code,{children:"T1"})," and ",(0,s.jsx)(n.code,{children:"T2"})," at address ",(0,s.jsx)(n.code,{children:"a"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module addr::M {\n    invariant [global] exists<T1>(a) == exists<T2>(a)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As written, the Move Prover will report that the invariant is violated after the call to ",(0,s.jsx)(n.code,{children:"publish1"})," and before the call to ",(0,s.jsx)(n.code,{children:"publish2"}),". If either of ",(0,s.jsx)(n.code,{children:"publish1"})," or ",(0,s.jsx)(n.code,{children:"publish2"})," is without the other, the Move Prover\nwill also report a violation of the invariant."]}),"\n",(0,s.jsxs)(n.p,{children:["By default, a global invariant is checked immediately after the instruction ",(0,s.jsx)(n.code,{children:"I"})," that touches the resources mentioned in the global invariant. The ",(0,s.jsx)(n.code,{children:"[suspendable]"})," attribute (at the invariant side) together with two pragmas (specified in function spec block) provide fine-grained control on where we hope this invariant to be checked:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"disable_invariants_in_body"}),": the invariant will be checked at the end of the function where ",(0,s.jsx)(n.code,{children:"I"})," resides."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"delegate_invariants_to_caller"}),": the invariant will be checked by all callers of the function where ",(0,s.jsx)(n.code,{children:"I"})," resides."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For the example above, we can add the pragma ",(0,s.jsx)(n.code,{children:"disable_invariants_in_body"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec setup {\n    pragma disable_invariants_in_body;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["which says that invariants are not required to hold while ",(0,s.jsx)(n.code,{children:"setup"})," is executing but are assumed to hold on entry to and exit from ",(0,s.jsx)(n.code,{children:"setup"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["This pragma changes the Move Prover's behavior. The invariants are assumed on entry to ",(0,s.jsx)(n.code,{children:"setup"})," but not proved during or after ",(0,s.jsx)(n.code,{children:"publish1"})," and ",(0,s.jsx)(n.code,{children:"publish2"}),". Instead, all invariants that could be invalidated in the\nbody of ",(0,s.jsx)(n.code,{children:"setup"})," are asserted and proved at the point of return from ",(0,s.jsx)(n.code,{children:"setup"}),". A consequence of this processing is that the user may need to provide stronger post-conditions on ",(0,s.jsx)(n.code,{children:"publish1"})," and ",(0,s.jsx)(n.code,{children:"publish2"})," to\nmake it possible to prove the invariants on exit from ",(0,s.jsx)(n.code,{children:"setup"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Another consequence of this processing is that invariants cannot safely be assumed to hold during the execution of ",(0,s.jsx)(n.code,{children:"publish1"})," and ",(0,s.jsx)(n.code,{children:"publish2"})," (unless nothing in the body of ",(0,s.jsx)(n.code,{children:"setup"})," changes state\nmentioned in the invariant). Therefore, if proving a post-condition requires the invariant to be assumed, the post-condition will fail."]}),"\n",(0,s.jsxs)(n.p,{children:["In the example, invariants hold at the call sites of ",(0,s.jsx)(n.code,{children:"setup"})," but not in the body. For ",(0,s.jsx)(n.code,{children:"publish1"}),", invariants don't necessarily hold at the call site ",(0,s.jsx)(n.em,{children:"or"})," in the body of the function. In the example, that\nbehavior is implied because ",(0,s.jsx)(n.code,{children:"publish1"})," is called in a context where invariants are disabled."]}),"\n",(0,s.jsxs)(n.p,{children:["When invariants are disabled in ",(0,s.jsx)(n.code,{children:"setup"})," in the above example, the Move Prover cannot assume them on entry to ",(0,s.jsx)(n.code,{children:"publish1"})," and ",(0,s.jsx)(n.code,{children:"publish2"})," and should not try to prove them on exit from those functions. The Move Prover\nwould have the same behavior for any functions called by ",(0,s.jsx)(n.code,{children:"publish1"})," or ",(0,s.jsx)(n.code,{children:"publish2"}),". The Move Prover ",(0,s.jsx)(n.em,{children:"automatically"})," adopts this behavior when invariants are disabled in a calling function, but it is possible for the user to declare that a function be treated like ",(0,s.jsx)(n.code,{children:"publish1"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if ",(0,s.jsx)(n.code,{children:"publish2"})," is ",(0,s.jsx)(n.em,{children:"only"})," called from the setup function above, and we did ",(0,s.jsx)(n.em,{children:"not"})," disable invariants in ",(0,s.jsx)(n.code,{children:"setup"}),", we could achieve a similar effect by using the pragma ",(0,s.jsx)(n.code,{children:"delegate_invariants_to_caller"}),", instead."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec setup {\n    pragma delegate_invariants_to_caller;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This would be legal only if ",(0,s.jsx)(n.code,{children:"setup"})," is a private or ",(0,s.jsx)(n.code,{children:"public (friend)"})," function. The difference between this and disabling invariants in ",(0,s.jsx)(n.code,{children:"setup"})," is that the invariants would not be assumed at the beginning of ",(0,s.jsx)(n.code,{children:"setup"})," and would be proved after ",(0,s.jsx)(n.code,{children:"setup"})," returns at each site where it is called."]}),"\n",(0,s.jsxs)(n.p,{children:["While both pragmas disable invariants in the body of a function, the difference is that ",(0,s.jsx)(n.code,{children:"disable_invariants_in_body"})," assumes invariants on entry and proves them on exit, while ",(0,s.jsx)(n.code,{children:"delegate_invariants_to_caller"})," does neither."]}),"\n",(0,s.jsxs)(n.p,{children:["There are some limitations on how these pragmas can be used. ",(0,s.jsx)(n.code,{children:"disable_invariants_in_body"})," cannot be declared for functions where invariants are delegated to a caller, either explicitly via the pragma\nor implicitly because the function is called in a context where invariants have been disabled. (This restriction is to ensure consistent processing, because on pragma assumes that invariants hold\nin the calling context and the other does not). Second, it is illegal for a public or script function to delegate invariant checking to its callers (since the Move Prover does not know all the call sites), ",(0,s.jsx)(n.em,{children:"unless"})," the function cannot possibly invalidate an invariant because it doesn't change any of the state mentioned in ",(0,s.jsx)(n.code,{children:"exists"})," and ",(0,s.jsx)(n.code,{children:"global"})," expressions appearing in the invariant."]}),"\n",(0,s.jsx)(n.h4,{id:"update-invariants",children:"Update invariants"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"update"})," form of a global invariant allows to express a relation between ",(0,s.jsx)(n.a,{href:"#pre-and-post-state",children:"pre-state and post-state"})," of a global state update. For example, the following invariant states that the counter must decrease monotonically whenever it is updated:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module addr::M {\n    invariant update [global] forall a: addr where old(exists<Counter>(a)) && exists<Counter>(addr):\n        global<Counter>(a).value <= old(global<Counter>(a));\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"isolated-global-invariants",children:"Isolated global invariants"}),"\n",(0,s.jsxs)(n.p,{children:["A global invariant can be marked as ",(0,s.jsx)(n.code,{children:"[isolated]"})," to indicate that it is not relevant for proving\nother properties of the program. An isolated global invariant will not be assumed when the related\nglobal state is read. It will only be assumed before the state is updated to help prove that the\ninvariant still holds after the update. This feature is for improving performance in situations\nwhere there are many global invariants, but they have no direct influence on verification."]}),"\n",(0,s.jsx)(n.h4,{id:"modular-verification-and-global-invariants",children:"Modular verification and global invariants"}),"\n",(0,s.jsx)(n.p,{children:'Certain usage of global invariants leads to verification problems that cannot be checked in a modular fashion. "Modular" here means that a module can be verified standalone and proven to be universally correct in all usage contexts (if preconditions are met).'}),"\n",(0,s.jsxs)(n.p,{children:["A non-modular verification problem may arise if a global invariant refers to state from multiple modules. Consider a situation where module ",(0,s.jsx)(n.code,{children:"M1"})," uses module ",(0,s.jsx)(n.code,{children:"M2"}),", and ",(0,s.jsx)(n.code,{children:"M1"})," contains the following invariant, with the helper function ",(0,s.jsx)(n.code,{children:"condition"})," referring to global state of each respective module:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"module addr::M1 {\n    invariant M1::condition() ==> M2::condition();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When we verify ",(0,s.jsx)(n.code,{children:"M1"})," standalone, the Move Prover will determine that it also needs to verify functions in ",(0,s.jsx)(n.code,{children:"M2"}),", namely those which update the M2 memory such that the invariant in M1 can fail."]}),"\n",(0,s.jsx)(n.h2,{id:"assume-and-assert-conditions-in-code",children:"Assume and assert conditions in code"}),"\n",(0,s.jsx)(n.p,{children:"A spec block might also occur anywhere an ordinary Move statement block can occur.\nHere is an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun simple1(x: u64, y: u64) {\n    let z;\n    y = x;\n    z = x + y;\n    spec {\n        assert x == y;\n        assert z == 2*x;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"In such inline spec blocks, only a subset of conditions are permitted:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"assume"})," and ",(0,s.jsx)(n.code,{children:"assert"})," statements are allowed in any code locations."]}),"\n",(0,s.jsxs)(n.li,{children:["loop ",(0,s.jsx)(n.code,{children:"invariant"})," statements are allowed only in code locations that represent loop headers."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An assert statement inside a spec block indicates a condition that must hold when control reaches\nthat block. If the condition does not hold, an error is reported by the Move Prover. An ",(0,s.jsx)(n.code,{children:"assume"}),"\nstatement, on the other hand, blocks executions violating the condition in the statement. The\nfunction ",(0,s.jsx)(n.code,{children:"simple2"})," shown below is verified by the Move Prover. However, if the first spec block\ncontaining the assume statement is removed, Move Prover will show a violation to the ",(0,s.jsx)(n.code,{children:"assert"}),"\nstatement in the second spec block."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun simple2(x: u64, y: u64) {\n    let z: u64;\n    spec {\n        assume x > y;\n    };\n    z = x + y;\n    spec {\n        assert z > 2*y;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"loop-invariants",children:"Loop invariants"}),"\n",(0,s.jsxs)(n.p,{children:["An ",(0,s.jsx)(n.code,{children:"invariant"})," statement encodes a loop invariant and must be placed at a loop head, as in the\nfollowing example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun simple3(n: u64) {\n    let x = 0\n    loop {\n        spec {\n            invariant x <= n;\n        };\n        if (x < n) {\n            x = x + 1\n        } else {\n            break\n        }\n    };\n    spec {\n        assert x == n;\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["A loop invariant is translated into two ",(0,s.jsx)(n.code,{children:"assert"})," statements and one ",(0,s.jsx)(n.code,{children:"assume"})," statement to facilitate the inductive reasoning of properties about the loop. In break down, a loop invariant is translated to:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.code,{children:"assert"})," statement that confirms the invariant holds when the loop is first encountered in the\nexecution -- establishing the base case."]}),"\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.code,{children:"assume"})," statement that encodes the property that the invariant holds at loop iteration ",(0,s.jsx)(n.code,{children:"I"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["An ",(0,s.jsx)(n.code,{children:"assert"})," statement that checks whether the invariant continues to hold at loop iteration ",(0,s.jsx)(n.code,{children:"I+1"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"referring-to-pre-state",children:"Referring to pre-state"}),"\n",(0,s.jsxs)(n.p,{children:["Occasionally, we would like to refer to the pre-state of a mutable function argument in inline spec\nblocks. In MSL, this can be done with the ",(0,s.jsx)(n.code,{children:"old(T)"})," expression. Similar to the semantics of ",(0,s.jsx)(n.code,{children:"old(..)"}),"\nin post conditions, an ",(0,s.jsx)(n.code,{children:"old(T)"})," expression in an ",(0,s.jsx)(n.code,{children:"assume"})," or ",(0,s.jsx)(n.code,{children:"assert"})," statement always yields the\nvalue of ",(0,s.jsx)(n.code,{children:"T"})," at the function entry point. Here is an example that illustrate the use of\n",(0,s.jsx)(n.code,{children:"old(..)"})," in an inline spec block:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun swap(x: &mut u64, y: &mut u64) {\n    let t = *x;\n    *x = *y;\n    *y = t;\n    spec {\n        assert x == old(y);\n        assert y == old(x);\n    };\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The above example is trivial as the same property can be expressed with post conditions\n(i.e., ",(0,s.jsx)(n.code,{children:"ensures"}),") too. But there are cases where we must use ",(0,s.jsx)(n.code,{children:"old(..)"})," to refer to the pre-state, especially in the specification of loop invariants. Consider the following example\nwhere we verify that the ",(0,s.jsx)(n.code,{children:"vector_reverse"})," function properly reverses the order of all elements\nin a vector:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"fun verify_reverse<Element>(v: &mut vector<Element>) {\n    let vlen = vector::length(v);\n    if (vlen == 0) return ();\n\n    let front_index = 0;\n    let back_index = vlen -1;\n    while ({\n        spec {\n            assert front_index + back_index == vlen - 1;\n            assert forall i in 0..front_index: v[i] == old(v)[vlen-1-i];\n            assert forall i in 0..front_index: v[vlen-1-i] == old(v)[i];\n            assert forall j in front_index..back_index+1: v[j] == old(v)[j];\n            assert len(v) == vlen;\n        };\n        (front_index < back_index)\n    }) {\n        vector::swap(v, front_index, back_index);\n        front_index = front_index + 1;\n        back_index = back_index - 1;\n    };\n}\nspec verify_reverse {\n    aborts_if false;\n    ensures forall i in 0..len(v): v[i] == old(v)[len(v)-1-i];\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note the usage of ",(0,s.jsx)(n.code,{children:"old(v)"})," in the loop invariants. Without them, it is hard to express the\ninvariant that the vector is partially reversed while the loop is iterating and the rest\nremain unchanged."]}),"\n",(0,s.jsxs)(n.p,{children:["However, unlike the ",(0,s.jsx)(n.code,{children:"old(T)"})," expressions in ",(0,s.jsx)(n.code,{children:"ensures"})," conditions where ",(0,s.jsx)(n.code,{children:"T"})," can be any valid\nexpression (e.g., ",(0,s.jsx)(n.code,{children:"old(v[i])"})," is allowed), the ",(0,s.jsx)(n.code,{children:"old(T)"})," expressions in ",(0,s.jsx)(n.code,{children:"assert"})," and ",(0,s.jsx)(n.code,{children:"assumes"}),"\nstatements accept only a single variable as ",(0,s.jsx)(n.code,{children:"T"})," and that variable must be a function argument of\na mutable reference type. In the above example, ",(0,s.jsx)(n.code,{children:"old(v[i])"})," is not allowed, and we should use\n",(0,s.jsx)(n.code,{children:"old(v)[i]"})," instead."]}),"\n",(0,s.jsx)(n.h2,{id:"specification-variables",children:"Specification variables"}),"\n",(0,s.jsxs)(n.p,{children:["MSL supports ",(0,s.jsx)(n.em,{children:"spec variables"}),", also called ",(0,s.jsx)(n.em,{children:"ghost variables"})," in the verification community. These\nvariables are used only in specifications and represent information derived from the global state of\nresources. An example use case is to compute the sum of all coins available in the system and\nspecify that the sum can be changed only in certain scenarios."]}),"\n",(0,s.jsxs)(n.p,{children:["We illustrate this feature by introducing a spec variable that maintains the sum of all ",(0,s.jsx)(n.code,{children:"Counter"}),"\nresources from our running example. First, a spec variable is introduced via spec module block as\nfollows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec module {\n    global sum_of_counters: num;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This value is going to be updated whenever a ",(0,s.jsx)(n.code,{children:"Counter"})," is packed or unpacked. (Recall that mutation\nis interpreted as an implicit unpack and pack):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec Counter {\n    invariant pack sum_of_counters = sum_of_counters + value;\n    invariant unpack sum_of_counters = sum_of_counters - value;\n}\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["TODO: ",(0,s.jsx)(n.code,{children:"invariant pack"})," and ",(0,s.jsx)(n.code,{children:"invariant unpack"})," are currently not implemented"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Now we may for example want to specify that the sum of all Counter instances in the global state\nshould never exceed a particular value. We can do this as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec module {\n    invariant [global] sum_of_counters < 4711;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Note that spec variables can also be referenced from helper functions. Moreover, spec variables can\nbe generic:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec module {\n    global some_generic_var<T>: num;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["When using such a spec variable, a type parameter must be provided, as in ",(0,s.jsx)(n.code,{children:"some_generic_var<u64>"}),". Effectively, a generic spec variable is like a family of variables indexed by types."]}),"\n",(0,s.jsx)(n.h2,{id:"schemas",children:"Schemas"}),"\n",(0,s.jsx)(n.p,{children:"Schemas are a means for structuring specifications by grouping properties together. Semantically,\nthey are just syntactic sugar that expand to conditions on functions, structs, or modules."}),"\n",(0,s.jsx)(n.h3,{id:"basic-schema-usage",children:"Basic Schema Usage"}),"\n",(0,s.jsx)(n.p,{children:"Schemas are used as such:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec schema IncrementAborts {\n    a: address;\n    aborts_if !exists<Counter>(a);\n    aborts_if global<Counter>(a).value == 255;\n}\n\nspec increment {\n    include IncrementAborts;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Each schema may declare a number of typed variable names and a list of conditions over those\nvariables. All supported condition types can be used in schemas. The schema can then be included in\nanother spec block:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"If that spec block is for a function or a struct, all variable names the schema declares must be\nmatched against existing names of compatible type in the context."}),"\n",(0,s.jsx)(n.li,{children:"If a schema is included in another schema, existing names are matched and must have the same type,\nbut non-existing names will be added as new declarations to the inclusion context."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["When a schema is included in another spec block, it will be checked whether the conditions it\ncontains are allowed in this block. For example, including the schema ",(0,s.jsx)(n.code,{children:"IncrementAborts"})," into a\nstruct spec block will lead to a compile-time error."]}),"\n",(0,s.jsxs)(n.p,{children:["When a schema is included, the names it declares can also bound by expressions. For example, one can\nwrite ",(0,s.jsx)(n.code,{children:"include IncrementAborts{a: some_helper_address()}"}),". Effectively, not providing a binding is\nequivalent to writing ",(0,s.jsx)(n.code,{children:"IncrementAborts{a: a}"})," if ",(0,s.jsx)(n.code,{children:"a"})," is an existing name in scope."]}),"\n",(0,s.jsx)(n.p,{children:"Schemas can be generic. Generic schemas must be fully instantiated where they are included; type\ninference is not available for schemas."}),"\n",(0,s.jsx)(n.h3,{id:"schema-expressions",children:"Schema expressions"}),"\n",(0,s.jsx)(n.p,{children:"When a schema is included, one can use a limited set of Boolean operators as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"P ==> SchemaExp"}),": all conditions in the schema will be prefixed with ",(0,s.jsx)(n.code,{children:"P ==> .."}),". Conditions that\nare not based on Boolean expressions will be rejected."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"if (P) SchemaExp1 else SchemaExp2"}),": this is treated similar to including both\n",(0,s.jsx)(n.code,{children:"P ==> SchemaExp1"})," and ",(0,s.jsx)(n.code,{children:"!P ==> SchemaExp2"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"SchemaExp1 && SchemaExp2"}),": this is treated as two includes for both schema expressions."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"schema-apply-operation",children:"Schema apply operation"}),"\n",(0,s.jsxs)(n.p,{children:["One of the main use cases for schemas is to be able to name a group of properties and then apply\nthose to a set of functions. This is achieved by the ",(0,s.jsx)(n.code,{children:"apply"})," operator. The ",(0,s.jsx)(n.code,{children:"apply"})," spec block member\ncan appear only in module spec blocks."]}),"\n",(0,s.jsxs)(n.p,{children:["The general form of the apply operator is ",(0,s.jsx)(n.code,{children:"apply Schema to FunctionPattern, .. except FunctionPattern, .."}),". Here, ",(0,s.jsx)(n.code,{children:"Schema"})," can be a schema name or a schema name plus formal type arguments. ",(0,s.jsx)(n.code,{children:"FunctionPatterns"})," consists of an optional visibility modifier ",(0,s.jsx)(n.code,{children:"public"})," or ",(0,s.jsx)(n.code,{children:"internal"})," (if not provided, both visibilities will match), a name pattern in the style of a shell file pattern ( e.g. ",(0,s.jsx)(n.code,{children:"*"}),", ",(0,s.jsx)(n.code,{children:"foo*"}),", ",(0,s.jsx)(n.code,{children:"foo*bar"}),", etc.), and finally an optional type argument list. All type arguments provided to ",(0,s.jsx)(n.code,{children:"Schema"})," must be bound\nin this list and vice versa."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"apply"})," operator includes the given schema in all function spec blocks that match the patterns,\nexcept those excluded via the ",(0,s.jsx)(n.code,{children:"except"})," patterns."]}),"\n",(0,s.jsxs)(n.p,{children:["A typical use of the ",(0,s.jsx)(n.code,{children:"apply"})," operator is to provide common pre-conditions and post-conditions to all functions in\na module with some exceptions. Example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec schema Unchanged {\n    let resource = global<R>(ADDR):\n    ensures resource == old(resource);\n}\n\nspec module {\n    // Enforce Unchanged for all functions except the initialize function.\n    apply Unchanged to * except initialize;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice that while with ",(0,s.jsx)(n.a,{href:"#global-invariants",children:"global invariants"})," we can express similar things, we ",(0,s.jsx)(n.em,{children:"cannot"}),"\nexpress the restriction of the invariant to only specific functions."]}),"\n",(0,s.jsx)(n.h2,{id:"opaque-specifications",children:"Opaque specifications"}),"\n",(0,s.jsxs)(n.p,{children:["With the pragma ",(0,s.jsx)(n.code,{children:"opaque"}),", a function is declared to be solely defined by its specification at caller\nsides. In contrast, if this pragma is not provided, then the function's implementation will be used\nas the basis to verify the caller."]}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"opaque"})," requires the specification to be sufficiently complete for the verification problem at hand. Without ",(0,s.jsx)(n.code,{children:"opaque"}),", the Move Prover will use the implementation as the source of truth for the definition of the function. But with ",(0,s.jsx)(n.code,{children:"opaque"}),", if there is an aspect of the function definition unspecified, an arbitrary meaning will be assumed. For example, with the specification below, the ",(0,s.jsx)(n.code,{children:"increment"})," function can abort under arbitrary conditions:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"spec increment {\n    pragma opaque;\n    // aborts_if !exists<Counter>(a);  // We need to add this to make the function not abort arbitrarily\n    ensures global<Counter>(a) == old(global<Counter>(a)) + 1;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In general, ",(0,s.jsx)(n.code,{children:"opaque"})," functions enable modular verification, as they abstract from the implementation\nof functions, resulting in much faster verification."]}),"\n",(0,s.jsxs)(n.p,{children:["If an ",(0,s.jsx)(n.code,{children:"opaque"})," function modifies state, it is advised to use the ",(0,s.jsxs)(n.a,{href:"#modifies-condition",children:[(0,s.jsx)(n.code,{children:"modifies"})," condition"]})," in its specification. If this is omitted, verification of the state changes will fail."]}),"\n",(0,s.jsx)(n.h2,{id:"abstract-specifications",children:"Abstract specifications"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"[abstract]"})," property allows specifying a function such that abstract semantics are used at the\ncaller side that is different from the actual implementation. This is useful if the implementation\nis too complex for verification, and abstract semantics are sufficient for verification goals.\nThe ",(0,s.jsx)(n.code,{children:"[concrete]"})," property, in turn, still allows specifying conditions that are verified against\nthe implementation but not used at the caller side."]}),"\n",(0,s.jsxs)(n.p,{children:["Consider the following example of a hash function. The actual value of the hash is not relevant for\nverification of callers, and we use an ",(0,s.jsx)(n.a,{href:"#uninterpreted-functions",children:"uninterpreted helper function"})," delivering an arbitrary value chosen by the Move Prover. We can still specify the concrete implementation and verify its correctness:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun hash(v: vector<u8>): u64 {\n    <<sum up values>>(v)\n}\nspec hash {\n    pragma opaque;\n    aborts_if false;\n    ensures [concrete] result == <<sum up values>>(v);\n    ensures [abstract] result == spec_hash_abstract(v);\n}\nspec fun abstract_hash(v: vector<u8>): u64; // uninterpreted function\n"})}),"\n",(0,s.jsx)(n.p,{children:"The soundness of the abstraction is the responsibility of the specifier and not verified by the\nMove Prover."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"NOTE: The abstract/concrete properties should only be used with opaque specifications, but the Move Prover will currently not generate an error message even though they are not used with opaque specifications."}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["NOTE: The ",(0,s.jsx)(n.code,{children:"modifies"})," clause does not currently support abstract/concrete. Also, if no modifies is given, the modified state will be computed from the implementation anyway, possibly conflicting with ",(0,s.jsx)(n.code,{children:"[abstract]"})," properties."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"documentation-generation",children:"Documentation generation"}),"\n",(0,s.jsx)(n.p,{children:"The organization of specification blocks in a file is relevant for documentation generation -- even\nthough it is not for the semantics."}),"\n",(0,s.jsx)(n.h1,{id:"expressiveness",children:"Expressiveness"}),"\n",(0,s.jsxs)(n.p,{children:["The Move specification language is expressive enough to represent the full Move language semantics (formal argument outstanding) with one exception: functions that return a ",(0,s.jsx)(n.code,{children:"&mut T"})," type."]}),"\n",(0,s.jsx)(n.p,{children:"Consider the following code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"struct S { x: u64, y: u64 }\n\nfun x_or_y(b: bool, s: &mut S): &mut u64 {\n    if (b) &mut s.x else &mut s.y\n}\nspec x_or_y {\n    ensures b ==> result == s.x;\n    ensures !b ==> result == s.y;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We are not able to specify the ",(0,s.jsx)(n.em,{children:"full"})," semantics of ",(0,s.jsx)(n.code,{children:"x_or_y"})," in MSL because we cannot capture the\nsemantics of mutable references. While we can say something about the value behind the reference at\nfunction exit, subsequent effects as in ",(0,s.jsx)(n.code,{children:"*x_or_y(b, &mut s) = 2"})," cannot be specified."]}),"\n",(0,s.jsxs)(n.p,{children:["However, the Move Prover ",(0,s.jsx)(n.em,{children:"does"})," understand the meaning of such functions -- the restriction is only\nin what we can specify. Practically, this means we cannot make the function ",(0,s.jsx)(n.code,{children:"x_or_y"})," opaque and must\nlet verification rely on that the Move Prover directly works with the implementation. Specifically, we\ncan verify the following (which can then be opaque):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-move",children:"fun x_or_y_test(s: S): S {\n    *x_or_y(true, &mut s) = 2;\n    s\n}\nspec x_or_y_test {\n    pragma opaque;\n    ensures result.x == 2;\n    ensures result.y == s.y;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"supporting-resources",children:"Supporting resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Design_by_contract",children:"Design by contract PRE_POST_REFERENCE"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/overview.md",children:"APTOS_FRAMEWORK"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},83581:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var s=i(11855);const t={},a=s.createContext(t);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);