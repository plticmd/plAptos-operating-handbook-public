"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[1522],{25694:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>b,frontMatter:()=>s,metadata:()=>c,toc:()=>i});var r=n(63159),o=n(83581);const s={title:"Configuring objects"},a="Configuring objects",c={id:"move/move-on-aptos/objects/configuring-objects",title:"Configuring objects",description:"At this point, you have an object, but how do you specialize it? Objects must",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/move-on-aptos/objects/configuring-objects.md",sourceDirName:"move/move-on-aptos/objects",slug:"/move/move-on-aptos/objects/configuring-objects",permalink:"/move/move-on-aptos/objects/configuring-objects",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/move-on-aptos/objects/configuring-objects.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{title:"Configuring objects"},sidebar:"appSidebar",previous:{title:"Creating objects",permalink:"/move/move-on-aptos/objects/creating-objects"},next:{title:"Using objects",permalink:"/move/move-on-aptos/objects/using-objects"}},l={},i=[{value:"Adding Resources",id:"adding-resources",level:2},{value:"Extending the object",id:"extending-the-object",level:2},{value:"Disabling or re-enabling Transfers",id:"disabling-or-re-enabling-transfers",level:2},{value:"Controlled transfers",id:"controlled-transfers",level:2},{value:"Allowing deletion of an Object",id:"allowing-deletion-of-an-object",level:2},{value:"Immutability",id:"immutability",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"configuring-objects",children:"Configuring objects"}),"\n",(0,r.jsx)(t.p,{children:"At this point, you have an object, but how do you specialize it? Objects must\nbe configured for their capabilities at creation time. If they are not\nconfigured with the correct capabilities at creation time, it will be impossible\nto change later."}),"\n",(0,r.jsx)(t.h2,{id:"adding-resources",children:"Adding Resources"}),"\n",(0,r.jsx)(t.p,{children:"An object must store data in resources. The signer of the object is required to\nmove resources to the object's storage. Below we'll go through a deletable\nobject example."}),"\n",(0,r.jsxs)(t.p,{children:["When I create my object, I can use the special ",(0,r.jsx)(t.code,{children:"ConstructorRef"})," to create\nresources only available at creation time. For example, you can create a signer\nat creation time to move a resource into the object."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-move",children:"module my_addr::object_playground {\n  use std::signer;\n  use aptos_framework::object;\n\n  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n  struct MyStruct has key {\n    num: u8\n  }\n\n  entry fun create_my_object(caller: &signer) {\n    let caller_address = signer::address_of(caller);\n\n    // Creates the object\n    let constructor_ref = object::create_object(caller_address);\n\n    // Retrieves a signer for the object\n    let object_signer = object::generate_signer(&constructor_ref);\n\n    // Moves the MyStruct resource into the object\n    move_to(&object_signer, MyStruct { num: 0 });\n\n    // ...\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"extending-the-object",children:"Extending the object"}),"\n",(0,r.jsxs)(t.p,{children:["The object was created, but the user decided to add extra data. The ",(0,r.jsx)(t.code,{children:"ExtendRef"}),"\nprovides this functionality to retrieve the object's ",(0,r.jsx)(t.code,{children:"signer"})," at a later time."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"ExtendRef"})," can be used to generate a signer for the object. Permissions on\nwho can retrieve it must be defined by the contract."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-move",children:"module my_addr::object_playground {\n  use std::signer;\n  use std::string::{self, String};\n  use aptos_framework::object::{self, Object};\n\n  /// Caller is not the owner of the object\n  const E_NOT_OWNER: u64 = 1;\n  /// Caller is not the publisher of the contract\n  const E_NOT_PUBLISHER: u64 = 2;\n\n  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n  struct MyStruct has key {\n    num: u8\n  }\n\n  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n  struct Message has key {\n    message: string::String\n  }\n\n  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n  struct ObjectController has key {\n    extend_ref: object::ExtendRef,\n  }\n\n  entry fun create_my_object(caller: &signer) {\n    let caller_address = signer::address_of(caller);\n\n    // Creates the object\n    let constructor_ref = object::create_object(caller_address);\n\n    // Retrieves a signer for the object\n    let object_signer = object::generate_signer(&constructor_ref);\n\n    // Moves the MyStruct resource into the object\n    move_to(&object_signer, MyStruct { num: 0 });\n\n    // Creates an extend ref, and moves it to the object\n    let extend_ref = object::generate_extend_ref(&constructor_ref);\n    move_to(&object_signer, ObjectController { extend_ref });\n    // ...\n  }\n\n  entry fun add_message(\n    caller: &signer,\n    object: Object<MyStruct>,\n    message: String\n  ) acquires ObjectController {\n    let caller_address = signer::address_of(caller);\n    // There are a couple ways to go about permissions\n\n    // Allow only the owner of the object\n    assert!(object::is_owner(object, caller_address), E_NOT_OWNER);\n    // Allow only the publisher of the contract\n    assert!(caller_address == @my_addr, E_NOT_PUBLISHER);\n    // Or any other permission scheme you can think of, the possibilities are endless!\n\n    // Use the extend ref to get a signer\n    let object_address = object::object_address(object);\n    let extend_ref = borrow_global<ObjectController>(object_address).extend_ref;\n    let object_signer = object::generate_signer_for_extending(&extend_ref);\n\n    // Extend the object to have a message\n    move_to(object_signer, Message { message });\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"disabling-or-re-enabling-transfers",children:"Disabling or re-enabling Transfers"}),"\n",(0,r.jsxs)(t.p,{children:["Objects can be able to be transferred or not. By default, all objects are\ntransferable. However, this functionality can be toggled on and off, or chosen\nat creation time. It is enabled by the ",(0,r.jsx)(t.code,{children:"TransferRef"}),", which we'll illustrate\nbelow."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-move",children:"module my_addr::object_playground {\n  use std::signer;\n  use std::string::{self, String};\n  use aptos_framework::object::{self, Object};\n\n  /// Caller is not the publisher of the contract\n  const E_NOT_PUBLISHER: u64 = 1;\n\n  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n  struct ObjectController has key {\n    transfer_ref: object::TransferRef,\n  }\n\n  entry fun create_my_object(\n    caller: &signer,\n    transferrable: bool,\n    controllable: bool\n  ) {\n    let caller_address = signer::address_of(caller);\n\n    // Creates the object\n    let constructor_ref = object::create_object(caller_address);\n\n    // Retrieves a signer for the object\n    let object_signer = object::generate_signer(&constructor_ref);\n\n    // Creates a transfer ref for controlling transfers\n    let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n\n    // We now have a choice, we can make it so the object can be transferred\n    // and we can decide if we want to allow it to change later.  By default, it\n    // is transferrable\n    if (!transferrable) {\n      object::disable_ungated_transfer(&transfer_ref);\n    };\n\n    // If we want it to be controllable, we must store the transfer ref for later\n    if (controllable) {\n      move_to(&object_signer, ObjectController { transfer_ref });\n    }\n    // ...\n  }\n\n  /// In this example, we'll only let the publisher of the contract change the\n  /// permissions of transferring\n  entry fun toggle_transfer(\n    caller: &signer,\n    object: Object<ObjectController>\n  ) acquires ObjectController {\n    // Only let the publisher toggle transfers\n    let caller_address = signer::address_of(caller);\n    assert!(caller_address == @my_addr, E_NOT_PUBLISHER);\n\n    // Retrieve the transfer ref\n    let object_address = object::object_address(object);\n    let transfer_ref = borrow_global<ObjectController>(\n      object_address\n    ).transfer_ref;\n\n    // Toggle it based on its current state\n    if (object::ungated_transfer_allowed(object)) {\n      object::disable_ungated_transfer(&transfer_ref);\n    } else {\n      object::enable_ungated_transfer(&transfer_ref);\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"controlled-transfers",children:"Controlled transfers"}),"\n",(0,r.jsxs)(t.p,{children:["Additionally, if the creator wants to control all transfers,\na ",(0,r.jsx)(t.code,{children:"LinearTransferRef"})," can be created from the ",(0,r.jsx)(t.code,{children:"TransferRef"})," to provide a one\ntime use transfer functionality. The ",(0,r.jsx)(t.code,{children:"LinearTransferRef"})," has to be used by the\nowner of the object."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-move",children:"module my_addr::object_playground {\n  use std::signer;\n  use std::option;\n  use std::string::{self, String};\n  use aptos_framework::object::{self, Object};\n\n  /// Caller is not the publisher of the contract\n  const E_NOT_PUBLISHER: u64 = 1;\n\n  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n  struct ObjectController has key {\n    transfer_ref: object::TransferRef,\n    linear_transfer_ref: option::Option<object::LinearTransferRef>,\n  }\n\n  entry fun create_my_object(\n    caller: &signer,\n    transferrable: bool,\n    controllable: bool\n  ) {\n    let caller_address = signer::address_of(caller);\n\n    // Creates the object\n    let constructor_ref = object::create_object(caller_address);\n\n    // Retrieves a signer for the object\n    let object_signer = object::generate_signer(&constructor_ref);\n\n    // Creates a transfer ref for controlling transfers\n    let transfer_ref = object::generate_transfer_ref(&constructor_ref);\n\n    // Disable ungated transfer\n    object::disable_ungated_transfer(&transfer_ref);\n    move_to(&object_signer, ObjectController {\n      transfer_ref,\n      linear_transfer_ref: option::none(),\n    });\n    // ...\n  }\n\n  /// In this example, we'll only let the publisher of the contract change the\n  /// permissions of transferring\n  entry fun allow_single_transfer(\n    caller: &signer,\n    object: Object<ObjectController>\n  ) acquires ObjectController {\n    // Only let the publisher toggle transfers\n    let caller_address = signer::address_of(caller);\n    assert!(caller_address == @my_addr, E_NOT_PUBLISHER);\n\n    let object_address = object::object_address(object);\n\n    // Retrieve the transfer ref\n    let transfer_ref = borrow_global<ObjectController>(\n      object_address\n    ).transfer_ref;\n\n    // Generate a one time use `LinearTransferRef`\n    let linear_transfer_ref = object::generate_linear_transfer_ref(\n      &transfer_ref\n    );\n\n    // Store it for later usage\n    let object_controller = borrow_global_mut<ObjectController>(\n      object_address\n    );\n    option::fill(\n      &mut object_controller.linear_transfer_ref,\n      linear_transfer_ref\n    )\n  }\n\n  /// Now only owner can transfer exactly once\n  entry fun transfer(\n    caller: &signer,\n    object: Object<ObjectController>,\n    new_owner: address\n  ) acquires ObjectController {\n    let object_address = object::object_address(object);\n\n    // Retrieve the linear_transfer ref, it is consumed so it must be extracted\n    // from the resource\n    let object_controller = borrow_global_mut<ObjectController>(\n      object_address\n    );\n    let linear_transfer_ref = option::extract(\n      &mut object_controller.linear_transfer_ref\n    );\n\n    object::transfer_with_ref(linear_transfer_ref, new_owner);\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"allowing-deletion-of-an-object",children:"Allowing deletion of an Object"}),"\n",(0,r.jsxs)(t.p,{children:["Deleting an object can be useful to get rid of clutter, as well as retrieve back\nstorage refunds. Deletion can be done with a ",(0,r.jsx)(t.code,{children:"DeleteRef"}),", which must be created\nat object creation time."]}),"\n",(0,r.jsxs)(t.p,{children:["Note that you cannot create a ",(0,r.jsx)(t.code,{children:"DeleteRef"})," for a non-deletable object."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-move",children:"module my_addr::object_playground {\n  use std::signer;\n  use std::option;\n  use std::string::{self, String};\n  use aptos_framework::object::{self, Object};\n\n  /// Caller is not the owner of the object\n  const E_NOT_OWNER: u64 = 1;\n\n  #[resource_group_member(group = aptos_framework::object::ObjectGroup)]\n  struct ObjectController has key {\n    delete_ref: object::DeleteRef,\n  }\n\n  entry fun create_my_object(\n    caller: &signer,\n    transferrable: bool,\n    controllable: bool\n  ) {\n    let caller_address = signer::address_of(caller);\n\n    // Creates the object\n    let constructor_ref = object::create_object(caller_address);\n\n    // Retrieves a signer for the object\n    let object_signer = object::generate_signer(&constructor_ref);\n\n    // Creates and store the delete ref\n    let delete_ref = object::generate_delete_ref(&constructor_ref);\n    move_to(&object_signer, ObjectController {\n      delete_ref\n    });\n    // ...\n  }\n\n  /// Now only let the owner delete the object\n  entry fun delete(\n    caller: &signer,\n    object: Object<ObjectController>,\n  ) {\n    // Only let caller delete\n    let caller_address = signer::address_of(caller);\n    assert!(object::is_owner(&object, caller_address), E_NOT_OWNER);\n\n    let object_address = object::object_address(object);\n\n    // Retrieve the delete ref, it is consumed so it must be extracted\n    // from the resource\n    let ObjectController {\n      delete_ref\n    } = move_from<ObjectController>(\n      object_address\n    );\n\n    // Delete the object forever!\n    object::delete(delete_ref);\n  }\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"immutability",children:"Immutability"}),"\n",(0,r.jsx)(t.p,{children:"An object can be made immutable by making the contract associated immutable, and\nremoving any ability to extend or mutate the object. By default, contracts are\nnot immutable, and objects can be extended with an ExtendRef, and resources can\nbe mutated if the contract allows for it."})]})}function b(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},83581:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var r=n(11855);const o={},s=r.createContext(o);function a(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);