"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[7997],{62827:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>f,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var s=t(63159),r=t(83581),i=t(45496),a=t(57376);const o={title:"Aptos Fungible Asset Standard",id:"fungible-asset"},d="Aptos Fungible Asset Standard",c={id:"standards/fungible-asset",title:"Aptos Fungible Asset Standard",description:"The Aptos Fungible Asset Standard (also known as Fungible Asset or FA) is a core framework component within Aptos that enables the tokenization of various assets, including commodities, real estate, and financial instruments. This standard facilitates the creation of decentralized financial applications.",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/standards/fungible-asset.md",sourceDirName:"standards",slug:"/standards/fungible-asset",permalink:"/standards/fungible-asset",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/standards/fungible-asset.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{title:"Aptos Fungible Asset Standard",id:"fungible-asset"},sidebar:"appSidebar",previous:{title:"Aptos Coin (Legacy)",permalink:"/standards/aptos-coin"},next:{title:"Aptos Digital Asset Standard",permalink:"/standards/digital-asset"}},l={},h=[{value:"Difference with Aptos Coin",id:"difference-with-aptos-coin",level:2},{value:"Structures",id:"structures",level:2},{value:"Metadata Object",id:"metadata-object",level:3},{value:"Fungible Asset and Fungible Store",id:"fungible-asset-and-fungible-store",level:3},{value:"References",id:"references",level:3},{value:"Creators",id:"creators",level:3},{value:"Users",id:"users",level:3},{value:"Primitives",id:"primitives",level:3},{value:"Mint",id:"mint",level:4},{value:"Burn",id:"burn",level:4},{value:"Transfer and Freeze/Unfreeze",id:"transfer-and-freezeunfreeze",level:4},{value:"Merging Fungible Assets",id:"merging-fungible-assets",level:4},{value:"Extracting Fungible Asset",id:"extracting-fungible-asset",level:4},{value:"Withdraw",id:"withdraw",level:4},{value:"Deposit",id:"deposit",level:4},{value:"Transfer",id:"transfer",level:4},{value:"Events",id:"events",level:2},{value:"How to enable Primary <code>FungibleStore</code>?",id:"how-to-enable-primary-fungiblestore",level:2},{value:"Primitives",id:"primitives-1",level:2},{value:"Get Primary <code>FungibleStore</code>",id:"get-primary-fungiblestore",level:3},{value:"Manually Create Primary <code>FungibleStore</code>",id:"manually-create-primary-fungiblestore",level:3},{value:"Check Balance and Frozen Status",id:"check-balance-and-frozen-status",level:3},{value:"Withdraw",id:"withdraw-1",level:3},{value:"Deposit",id:"deposit-1",level:3},{value:"Transfer",id:"transfer-1",level:3},{value:"Secondary <code>FungibleStore</code>",id:"secondary-fungiblestore",level:2},{value:"Ownership of <code>FungibleStore</code>",id:"ownership-of-fungiblestore",level:2}];function u(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"aptos-fungible-asset-standard",children:"Aptos Fungible Asset Standard"}),"\n",(0,s.jsx)(n.p,{children:"The Aptos Fungible Asset Standard (also known as Fungible Asset or FA) is a core framework component within Aptos that enables the tokenization of various assets, including commodities, real estate, and financial instruments. This standard facilitates the creation of decentralized financial applications."}),"\n",(0,s.jsx)(n.p,{children:"The tokenization of securities and commodities provides fractional ownership, making these markets more accessible to a broader range of investors.\nFungible tokens can also represent real estate ownership, enabling fractional ownership and providing liquidity to a traditionally illiquid market.\nIn-game assets such as virtual currencies and characters can be tokenized, enabling players to own and trade their assets and creating new revenue streams for game developers and players."}),"\n",(0,s.jsx)(n.p,{children:"Besides the aforementioned features, Fungible Asset (FA) is a superset of cryptocurrency, as coin is just one type of Fungible Asset. The Fungible Asset framework could replace the coin module in Move."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/sources/fungible_asset.move",children:"Fungible Asset module"})," provides a standard, type-safe framework for defining FAs within the Aptos Move ecosystem."]}),"\n",(0,s.jsxs)(n.p,{children:["The standard is built upon ",(0,s.jsx)(n.a,{href:"/standards/aptos-object",children:"Aptos object model"}),", so all the resources defined here are included in the object resource group and stored inside objects.\nThere are two types of objects related to FA:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Object<Metadata>"}),": include information about the FA, such as name, symbol, and decimals."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Object<FungibleStore>"}),": store a specific amount of FA units. FAs are units that are interchangeable with others of the same metadata. They can be stored in objects that contain a FungibleStore resource. These store objects can be freely created, and FAs can be moved, split, and combined between them easily."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The standard also supports minting new units and burning existing units with appropriate controls."}),"\n",(0,s.jsxs)(n.p,{children:["The different objects involved - ",(0,s.jsx)(n.code,{children:"Object<Metadata>"})," and ",(0,s.jsx)(n.code,{children:"Object<FungibleStore>"})," objects, and their relationships to accounts are shown in the diagram below:"]}),"\n",(0,s.jsx)("div",{style:{textAlign:"center"},children:(0,s.jsx)(i.A,{alt:"fungible asset architecture",sources:{light:(0,a.A)("/img/docs/fungible-asset.svg"),dark:(0,a.A)("/img/docs/fungible-asset-dark.svg")}})}),"\n",(0,s.jsx)(n.h2,{id:"difference-with-aptos-coin",children:"Difference with Aptos Coin"}),"\n",(0,s.jsxs)(n.p,{children:["FA is a broader category than just coins. While fungible coins are just one possible use case of FA, it can represent a wider range of fungible items, such as in-game assets like gems or rocks, event tickets, and partial ownership of real-world assets. FA provides the flexibility for customizable, detailed management and offers a new programming model based on objects.\nFor Aptos coin, a ",(0,s.jsx)(n.code,{children:"Coin"})," uses a generic, or the ",(0,s.jsx)(n.code,{children:"CoinType"}),", to support distinct typing within the Coin framework. For example, ",(0,s.jsx)(n.code,{children:"Coin<A>"})," and ",(0,s.jsx)(n.code,{children:"Coin<B>"})," are two distinct coins, if ",(0,s.jsx)(n.code,{children:"A != B"}),". In contrast, FA does not have a generic in struct definition but uses the metadata reference to distinguish the type, which will be further explained later.\nMinimally, ",(0,s.jsx)(n.a,{href:"/standards/aptos-coin",children:"Aptos coin"})," should be interchangeable with FA. The migration plan is under discussion."]}),"\n",(0,s.jsx)(n.h2,{id:"structures",children:"Structures"}),"\n",(0,s.jsx)(n.h3,{id:"metadata-object",children:"Metadata Object"}),"\n",(0,s.jsxs)(n.p,{children:["Metadata objects with unique addresses define the type of the FAs. Even if ",(0,s.jsx)(n.code,{children:"Metadata"})," structs of two ",(0,s.jsx)(n.code,{children:"Object<Metadata>"})," are exactly the same, as long as their addresses are different, the FAs points to them would be different. In short, the address of the metadata object can be used as ",(0,s.jsx)(n.strong,{children:"unique identifier"})," of the FA type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[resource_group_member(group = aptos_framework::object::ObjectGroup)]\nstruct Metadata has key {\n    supply: Option<Supply>,\n    /// Name of the fungible metadata, i.e., "USDT".\n    name: String,\n    /// Symbol of the fungible metadata, usually a shorter version of the name.\n    /// For example, Singapore Dollar is SGD.\n    symbol: String,\n    /// Number of decimals used for display purposes.\n    /// For example, if `decimals` equals `2`, a balance of `505` coins should\n    /// be displayed to a user as `5.05` (`505 / 10 ** 2`).\n    decimals: u8,\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"fungible-asset-and-fungible-store",children:"Fungible Asset and Fungible Store"}),"\n",(0,s.jsx)(n.p,{children:"FA allows typing by allocating an object reference that points to the metadata. Hence, a set of units of FA is represented as an amount and a reference to the metadata, as shown:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct FungibleAsset {\n    metadata: Object<Metadata>,\n    amount: u64,\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The FAs is a struct representing the type and the amount of units held. As the struct does not have either key or store abilities, it can only be passed from one function to another but must be consumed by the end of a transaction. Specifically, it must be deposited back into a fungible store at the end of the transaction, which is defined as:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[resource_group_member(group = aptos_framework::object::ObjectGroup)]\nstruct FungibleStore has key {\n    /// The address of the base metadata object.\n    metadata: Object<Metadata>,\n    /// The balance of the fungible metadata.\n    balance: u64,\n    /// FAs transferring is a common operation, this allows for freezing/unfreezing accounts.\n    frozen: bool,\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["FAs are always stored in the top-level ",(0,s.jsx)(n.code,{children:"FungibleStore"})," resource. This makes it much easier to find, analyze, and control."]})}),"\n",(0,s.jsxs)(n.p,{children:["The only extra field added here is ",(0,s.jsx)(n.code,{children:"frozen"}),". if it is ",(0,s.jsx)(n.code,{children:"true"}),", this object is frozen, i.e., deposit and withdraw are both disabled without using ",(0,s.jsx)(n.code,{children:"TransferRef"})," in the next section."]}),"\n",(0,s.jsx)(n.h3,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Reference"})," (ref) is the means to implement granular permission control across different standards in Aptos. In different contexts, it may be called ",(0,s.jsx)(n.em,{children:"capabilities"}),". The FA standard has three distinct refs for minting, transferring, and burning FA: ",(0,s.jsx)(n.code,{children:"MintRef"}),", ",(0,s.jsx)(n.code,{children:"TransferRef"}),", and ",(0,s.jsx)(n.code,{children:"BurnRef"}),". Each ref contains a reference to the FA metadata:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct MintRef has drop, store {\n    metadata: Object<Metadata>\n}\n\nstruct TransferRef has drop, store {\n    metadata: Object<Metadata>\n}\n\nstruct BurnRef has drop, store {\n    metadata: Object<Metadata>\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Ref owners can do the following operations depending on the refs they own:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MintRef"})," offers the capability to mint new FA units."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TransferRef"})," offers the capability to mutate the value of ",(0,s.jsx)(n.code,{children:"freeze"})," in any ",(0,s.jsx)(n.code,{children:"FungibleStore"})," of the same metadata or transfer FA by ignoring ",(0,s.jsx)(n.code,{children:"freeze"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BurnRef"})," offers the capability to burn or delete FA units."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The three refs collectively act as the building blocks of various permission control systems as they have ",(0,s.jsx)(n.code,{children:"store"})," so can be passed around and stored anywhere. Please refer to the source file for ",(0,s.jsx)(n.code,{children:"mint()"}),", ",(0,s.jsx)(n.code,{children:"mint_to()"}),", ",(0,s.jsx)(n.code,{children:"burn()"}),", ",(0,s.jsx)(n.code,{children:"burn_from()"}),", ",(0,s.jsx)(n.code,{children:"withdraw_with_ref()"}),", ",(0,s.jsx)(n.code,{children:"deposit_with_ref()"}),", and ",(0,s.jsx)(n.code,{children:"transfer_with_ref()"}),": These functions are used to mint, burn, withdraw, deposit, and transfer FA using the MintRef, BurnRef, and TransferRef."]}),"\n",(0,s.jsxs)(n.p,{children:["Note, these are framework functions and must be combined with business logic to produce a usable system. Developers who want to use these functions should familiarize themselves with the concepts of ",(0,s.jsx)(n.a,{href:"/standards/aptos-object",children:"Aptos object model"})," and understand how the reference system enables extensible designs within Aptos move."]}),"\n",(0,s.jsx)(n.h3,{id:"creators",children:"Creators"}),"\n",(0,s.jsxs)(n.p,{children:["A Fungible Asset creator can add fungibility to any ",(0,s.jsx)(n.strong,{children:"non-deletable"})," object at creation by taking ",(0,s.jsx)(n.code,{children:"&ConstructorRef"})," with the required information to\nmake that object a metadata of the associated FA. Then FA of this metadata can be minted and used. It is noted here that\n",(0,s.jsx)(n.strong,{children:"non-deletable"})," means the ",(0,s.jsx)(n.code,{children:"can_delete"})," field of ",(0,s.jsx)(n.code,{children:"&ConstructorRef"})," has to be ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun add_fungibility(\n    constructor_ref: &ConstructorRef,\n    maximum_supply: Option<u128>,\n    name: String,\n    symbol: String,\n    decimals: u8,\n    icon_uri: String,\n    project_uri: String,\n): Object<Metadata>\n"})}),"\n",(0,s.jsx)(n.p,{children:"The creator has the opportunity to define a name, symbol, decimals, icon URI, project URI, and whether the total supply for the FA has a maximum. The following applies:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The first three of the above (",(0,s.jsx)(n.code,{children:"name"}),", ",(0,s.jsx)(n.code,{children:"symbol"}),", ",(0,s.jsx)(n.code,{children:"decimals"}),", ",(0,s.jsx)(n.code,{children:"icon_uri"}),", ",(0,s.jsx)(n.code,{children:"project_uri"}),") are purely metadata and have no impact for on-chain\napplications. Some applications may use decimals to equate a single Coin from a fractional coin."]}),"\n",(0,s.jsxs)(n.li,{children:["Maximum supply (",(0,s.jsx)(n.code,{children:"maximum_supply"}),") helps check the total supply does not exceed a maximum value. However, due to the way the parallel executor\nworks, setting the maximum supply will prevent any parallel execution of mint and burn."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"users",children:"Users"}),"\n",(0,s.jsx)(n.p,{children:"Users are FA holders, who can:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Merge two FAs of the same metadata object."}),"\n",(0,s.jsx)(n.li,{children:"Extract FA partially from another."}),"\n",(0,s.jsxs)(n.li,{children:["Deposit to and withdraw from a ",(0,s.jsx)(n.code,{children:"FungibleStore"})," and emit events as a result."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"primitives",children:"Primitives"}),"\n",(0,s.jsxs)(n.p,{children:["At creation, the creator has the option to generate refs from the same ",(0,s.jsx)(n.code,{children:"&ConstructorRef"})," to manage FA. These will need\nto be stored in global storage to be used later."]}),"\n",(0,s.jsx)(n.h4,{id:"mint",children:"Mint"}),"\n",(0,s.jsxs)(n.p,{children:["If the manager would like to mint FA, they must retrieve a reference to ",(0,s.jsx)(n.code,{children:"MintRef"})," and call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun mint(ref: &MintRef, amount: u64): FungibleAsset\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will produce a new FA of the metadata in the ref, containing a value as dictated by the ",(0,s.jsx)(n.code,{children:"amount"}),". The supply will also be adjusted. Also, there is a ",(0,s.jsx)(n.code,{children:"mint_to"})," function that deposits to a ",(0,s.jsx)(n.code,{children:"FungibleStore"}),"\nafter minting as a helper."]}),"\n",(0,s.jsx)(n.h4,{id:"burn",children:"Burn"}),"\n",(0,s.jsxs)(n.p,{children:["The opposite operation of minting. Likewise, a reference to ",(0,s.jsx)(n.code,{children:"BurnRef"})," is required and call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun burn(ref: &BurnRef, fa: FungibleAsset)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will reduce the passed-in ",(0,s.jsx)(n.code,{children:"fa"})," to ashes and adjust the supply. There is also a ",(0,s.jsx)(n.code,{children:"burn_from"})," function that forcibly withdraws FA\nfrom an account first and then burns the withdrawn FA as a helper."]}),"\n",(0,s.jsx)(n.h4,{id:"transfer-and-freezeunfreeze",children:"Transfer and Freeze/Unfreeze"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"TransferRef"})," has two functions:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Flip ",(0,s.jsx)(n.code,{children:"frozen"})," in ",(0,s.jsx)(n.code,{children:"FungibleStore"})," holding FA of the same metadata in the ",(0,s.jsx)(n.code,{children:"TransferRef"}),'. if\nit is false, the store is "frozen" that nobody can deposit to or withdraw from this store without using the ref.']}),"\n",(0,s.jsxs)(n.li,{children:["Withdraw from or deposit to a store ignoring ",(0,s.jsx)(n.code,{children:"frozen"})," field."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To change ",(0,s.jsx)(n.code,{children:"frozen"}),", call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun set_frozen_flag<T: key>(\n    ref: &TransferRef,\n    store: Object<T>,\n    frozen: bool,\n)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This function will emit a ",(0,s.jsx)(n.code,{children:"FrozenEvent"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"To forcibly withdraw, call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Rust",children:"public fun withdraw_with_ref<T: key>(\n    ref: &TransferRef,\n    store: Object<T>,\n    amount: u64\n): FungibleAsset\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This function will emit a ",(0,s.jsx)(n.code,{children:"WithdrawEvent"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"To forcibly deposit, call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun deposit_with_ref<T: key>(\n    ref: &TransferRef,\n    store: Object<T>,\n    fa: FungibleAsset\n)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This function will emit a ",(0,s.jsx)(n.code,{children:"DepositEvent"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["There is a function named ",(0,s.jsx)(n.code,{children:"transfer_with_ref"})," that combining ",(0,s.jsx)(n.code,{children:"withdraw_with_ref"})," and ",(0,s.jsx)(n.code,{children:"deposit_with_ref"})," together as\na helper."]}),"\n",(0,s.jsx)(n.h4,{id:"merging-fungible-assets",children:"Merging Fungible Assets"}),"\n",(0,s.jsxs)(n.p,{children:["Two FAs of the same type can be merged into a single struct that represents the accumulated value of the two",(0,s.jsx)(n.br,{}),"\n","independently by calling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun merge(dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After merging, ",(0,s.jsx)(n.code,{children:"dst_fungible_asset"})," will have all the amounts."]}),"\n",(0,s.jsx)(n.h4,{id:"extracting-fungible-asset",children:"Extracting Fungible Asset"}),"\n",(0,s.jsxs)(n.p,{children:["A Fungible Asset can have ",(0,s.jsx)(n.code,{children:"amount"})," deducted to create another FA by calling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun extract(fungible_asset: &mut FungibleAsset, amount: u64): FungibleAsset\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This function may produce FA with 0 amount, which is not usable. It is supposed to be merged with other FA or destroyed\nthrough ",(0,s.jsx)(n.code,{children:"destroy_zero()"})," in the module."]})}),"\n",(0,s.jsx)(n.h4,{id:"withdraw",children:"Withdraw"}),"\n",(0,s.jsxs)(n.p,{children:["The owner of a ",(0,s.jsx)(n.code,{children:"FungibleStore"})," object that is not frozen can extract FA with a specified amount, by calling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun withdraw<T: key>(owner: &signer, store: Object<T>, amount: u64): FungibleAsset\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This function will emit a ",(0,s.jsx)(n.code,{children:"WithdrawEvent"}),"."]})}),"\n",(0,s.jsx)(n.h4,{id:"deposit",children:"Deposit"}),"\n",(0,s.jsxs)(n.p,{children:["Any entity can deposit FA into a ",(0,s.jsx)(n.code,{children:"FungibleStore"})," object that is not frozen, by calling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun deposit<T: key>(store: Object<T>, fa: FungibleAsset)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This function will emit a ",(0,s.jsx)(n.code,{children:"DepositEvent"}),"."]})}),"\n",(0,s.jsx)(n.h4,{id:"transfer",children:"Transfer"}),"\n",(0,s.jsxs)(n.p,{children:["The owner of a ",(0,s.jsx)(n.code,{children:"FungibleStore"})," can directly transfer FA from that store to another if neither is frozen by calling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public entry fun transfer<T: key>(sender: &signer, from: Object<T>, to: Object<T>, amount: u64)\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This will emit both ",(0,s.jsx)(n.code,{children:"WithdrawEvent"})," and ",(0,s.jsx)(n.code,{children:"DepositEvent"})," on the respective ",(0,s.jsx)(n.code,{children:"Fungibletore"}),"s."]})}),"\n",(0,s.jsx)(n.h2,{id:"events",children:"Events"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DepositEvent"}),": Emitted when FAs are deposited into a store."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"WithdrawEvent"}),": Emitted when FAs are withdrawn from a store."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FrozenEvent"}),": Emitted when the frozen status of a fungible store is updated."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct DepositEvent has drop, store {\n    amount: u64,\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct WithdrawEvent has drop, store {\n    amount: u64,\n}\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"struct FrozenEvent has drop, store {\n    frozen: bool,\n}\n"})}),"\n",(0,s.jsxs)(n.h1,{id:"primary-and-secondary-fungiblestores",children:["Primary and secondary ",(0,s.jsx)(n.code,{children:"FungibleStore"}),"s"]}),"\n",(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(n.code,{children:"FungibleStore"})," object has an owner. However, an owner may possess more than one store. When Alice sends FA to\nBob, how does she determine the correct destination? Additionally, what happens if Bob doesn't have a store yet?"]}),"\n",(0,s.jsx)(n.p,{children:"To address these questions, the standard has been expanded to define primary and secondary stores."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Each account owns only one non-deletable primary store for each type of FA, the address of which is derived in a deterministic\nmanner from the account address and metadata object address. If primary store does not exist, it will be created if\nFA is going to be deposited by calling functions defined in ",(0,s.jsx)(n.code,{children:"primary_fungible_store.move"})]}),"\n",(0,s.jsx)(n.li,{children:"Secondary stores do not have deterministic addresses and are theoretically deletable. Users are able to create as many\nsecondary stores as they want using the provided functions but there is a caveat that addressing secondary stores\non-chain may need extra work."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The vast majority of users will have primary store as their only store for a specific type of FAs. It is\nexpected that secondary stores would be useful in complicated defi or other asset management contracts that will be\nintroduced in other tutorials using FA."}),"\n",(0,s.jsxs)(n.h2,{id:"how-to-enable-primary-fungiblestore",children:["How to enable Primary ",(0,s.jsx)(n.code,{children:"FungibleStore"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["To add primary store support, when creating a metadata object, instead of the aforementioned ",(0,s.jsx)(n.code,{children:"add_fungibility()"}),", the creator\nhas to call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun create_primary_store_enabled_fungible_asset(\n    constructor_ref: &ConstructorRef,\n    maximum_supply: Option<u128>,\n    name: String,\n    symbol: String,\n    decimals: u8,\n    icon_uri: String,\n    project_uri: String,\n)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The parameters are the same as those of ",(0,s.jsx)(n.code,{children:"add_fungibility()"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"primitives-1",children:"Primitives"}),"\n",(0,s.jsxs)(n.h3,{id:"get-primary-fungiblestore",children:["Get Primary ",(0,s.jsx)(n.code,{children:"FungibleStore"})]}),"\n",(0,s.jsx)(n.p,{children:"To get the primary store object of a metadata object belonging to an account, call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun primary_store<T: key>(owner: address, metadata: Object<T>): Object<FungibleStore>\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["There are other utility functions. ",(0,s.jsx)(n.code,{children:"primary_store_address"})," returns the deterministic address the primary store,\nand ",(0,s.jsx)(n.code,{children:"primary_store_exists"})," checks the existence, etc."]})}),"\n",(0,s.jsxs)(n.h3,{id:"manually-create-primary-fungiblestore",children:["Manually Create Primary ",(0,s.jsx)(n.code,{children:"FungibleStore"})]}),"\n",(0,s.jsx)(n.p,{children:"If a primary store does not exist, any entity is able to create it by calling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun create_primary_store<T: key>(owner_addr: address, metadata: Object<T>): Object<FungibleStore>\n"})}),"\n",(0,s.jsx)(n.h3,{id:"check-balance-and-frozen-status",children:"Check Balance and Frozen Status"}),"\n",(0,s.jsx)(n.p,{children:"To check the balance of a primary store, call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun balance<T: key>(account: address, metadata: Object<T>): u64\n"})}),"\n",(0,s.jsx)(n.p,{children:"To check whether the given account's primary store is frozen, call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun is_frozen<T: key>(account: address, metadata: Object<T>): bool\n"})}),"\n",(0,s.jsx)(n.h3,{id:"withdraw-1",children:"Withdraw"}),"\n",(0,s.jsx)(n.p,{children:"An owner can withdraw FA from their primary store by calling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun withdraw<T: key>(owner: &signer, metadata: Object<T>, amount: u64): FungibleAsset\n"})}),"\n",(0,s.jsx)(n.h3,{id:"deposit-1",children:"Deposit"}),"\n",(0,s.jsx)(n.p,{children:"An owner can deposit FA to their primary store by calling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun deposit(owner: address, fa: FungibleAsset)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"transfer-1",children:"Transfer"}),"\n",(0,s.jsx)(n.p,{children:"An owner can deposit FA from their primary store to that of another account by calling:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public entry fun transfer<T: key>(sender: &signer, metadata: Object<T>, recipient: address, amount: u64)\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"secondary-fungiblestore",children:["Secondary ",(0,s.jsx)(n.code,{children:"FungibleStore"})]}),"\n",(0,s.jsx)(n.p,{children:"Secondary stores are not commonly used by normal users but prevailing for smart contracts to manage assets owned by\ncontracts. For example, an asset pool may have to manage multiple fungible stores for one or more types of FA. Those\nstores do not necessarily have to have deterministic addresses and a user may have multiple stores for a given kind of\nFA. So primary fungible store is not a good fit for the needs where secondary store plays a vital role."}),"\n",(0,s.jsxs)(n.p,{children:["The way to create secondary store is to create an object first and get its ",(0,s.jsx)(n.code,{children:"ConstructorRef"}),". Then call:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"public fun create_store<T: key>(\n    constructor_ref: &ConstructorRef,\n    metadata: Object<T>,\n): Object<FungibleStore>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["It will turn make the newly created object a ",(0,s.jsx)(n.code,{children:"FungibleStore"}),". Sometimes an object can be reused as a store. For example,\na metadata object can also be a store to hold some FA of its own type or a liquidity pool object can be a store of the\nissued liquidity pool's token/coin."]}),"\n",(0,s.jsxs)(n.h2,{id:"ownership-of-fungiblestore",children:["Ownership of ",(0,s.jsx)(n.code,{children:"FungibleStore"})]}),"\n",(0,s.jsxs)(n.p,{children:["It is crucial to set correct owner of a ",(0,s.jsx)(n.code,{children:"FungibleStore"})," object for managing the FA stored inside. By default, the owner\nof a newly created object is the creator whose ",(0,s.jsx)(n.code,{children:"signer"})," is passed into the creation function. For ",(0,s.jsx)(n.code,{children:"FungibleStore"}),"\nobjects managed by smart contract itself, usually they shouldn't have an owner out of the control of this contract. For\nthose cases, those objects could make themselves as their owners and keep their object ",(0,s.jsx)(n.code,{children:"ExtendRef"})," at the proper place\nto create ",(0,s.jsx)(n.code,{children:"signer"})," as needed by the contract logic."]})]})}function f(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},83581:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(11855);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);