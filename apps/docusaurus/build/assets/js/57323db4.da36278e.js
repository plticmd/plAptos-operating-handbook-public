"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[5491],{86159:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>d,toc:()=>i});var o=s(63159),t=s(83581);const r={},a="Modules and Scripts",d={id:"move/book/modules-and-scripts",title:"Modules and Scripts",description:"Move has two different types of programs: Modules_** and Scripts_. Modules are libraries that define struct types along with functions that operate on these types. Struct types define the schema of Move's global storage, and module functions define the rules for updating storage. Modules themselves are also stored in global storage. A scripts is an executable entrypoint similar to a main function in a conventional language. A script typically calls functions of a published module that perform updates to global storage. Scripts are ephemeral code snippets that are not published in global storage.",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/book/modules-and-scripts.md",sourceDirName:"move/book",slug:"/move/book/modules-and-scripts",permalink:"/move/book/modules-and-scripts",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/book/modules-and-scripts.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{},sidebar:"appSidebar",previous:{title:"Introduction",permalink:"/move/book/introduction"},next:{title:"Move\u30c1\u30e5\u30fc\u30c8\u30ea\u30a2\u30eb",permalink:"/move/book/creating-coins"}},l={},i=[{value:"Syntax",id:"syntax",level:2},{value:"Scripts",id:"scripts",level:3},{value:"Modules",id:"modules",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"modules-and-scripts",children:"Modules and Scripts"}),"\n",(0,o.jsxs)(n.p,{children:["Move has two different types of programs: ",(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.em,{children:"Modules"})})," and ",(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.em,{children:"Scripts"})}),". Modules are libraries that define struct types along with functions that operate on these types. Struct types define the schema of Move's ",(0,o.jsx)(n.a,{href:"/move/book/global-storage-structure",children:"global storage"}),", and module functions define the rules for updating storage. Modules themselves are also stored in global storage. A scripts is an executable entrypoint similar to a ",(0,o.jsx)(n.code,{children:"main"})," function in a conventional language. A script typically calls functions of a published module that perform updates to global storage. Scripts are ephemeral code snippets that are not published in global storage."]}),"\n",(0,o.jsxs)(n.p,{children:["A Move source file (or ",(0,o.jsx)(n.strong,{children:"compilation unit"}),") may contain multiple modules and scripts. However, publishing a module or executing a script are separate VM operations."]}),"\n",(0,o.jsx)(n.h2,{id:"syntax",children:"Syntax"}),"\n",(0,o.jsx)(n.h3,{id:"scripts",children:"Scripts"}),"\n",(0,o.jsx)(n.admonition,{title:"Tutorial",type:"tip",children:(0,o.jsxs)(n.p,{children:["To learn how to publish and execute a Move script, follow the ",(0,o.jsx)(n.a,{href:"/move/move-on-aptos/scripts/script-tutorial",children:"Move Scripts"})," example."]})}),"\n",(0,o.jsx)(n.p,{children:"A script has the following structure:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"script {\n    <use>*\n    <constants>*\n    fun <identifier><[type parameters: constraint]*>([identifier: type]*) <function_body>\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.code,{children:"script"})," block must start with all of its ",(0,o.jsx)(n.a,{href:"/move/book/uses",children:(0,o.jsx)(n.code,{children:"use"})})," declarations, followed by any ",(0,o.jsx)(n.a,{href:"/move/book/constants",children:"constants"})," and (finally) the main\n",(0,o.jsx)(n.a,{href:"/move/book/functions",children:"function"})," declaration.\nThe main function can have any name (i.e., it need not be called ",(0,o.jsx)(n.code,{children:"main"}),"), is the only function in a script block, can have any number of\narguments, and must not return a value. Here is an example with each of these components:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"script {\n    // Import the debug module published at the named account address std.\n    use std::debug;\n\n    const ONE: u64 = 1;\n\n    fun main(x: u64) {\n        let sum = x + ONE;\n        debug::print(&sum)\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Scripts have very limited power\u2014they cannot declare friends, struct types or access global storage. Their primary purpose is to invoke module functions."}),"\n",(0,o.jsx)(n.h3,{id:"modules",children:"Modules"}),"\n",(0,o.jsx)(n.p,{children:"A module has the following syntax:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-text",children:"module <address>::<identifier> {\n    (<use> | <friend> | <type> | <function> | <constant>)*\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["where ",(0,o.jsx)(n.code,{children:"<address>"})," is a valid ",(0,o.jsx)(n.a,{href:"/move/book/address",children:"named or literal address"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module 0x42::example {\n    struct Example has copy, drop { i: u64 }\n\n    use std::debug;\n    friend 0x42::another_example;\n\n    const ONE: u64 = 1;\n\n    public fun print(x: u64) {\n        let sum = x + ONE;\n        let example = Example { i: sum };\n        debug::print(&sum)\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"module 0x42::example"})," part specifies that the module ",(0,o.jsx)(n.code,{children:"example"})," will be published under the ",(0,o.jsx)(n.a,{href:"/move/book/address",children:"account address"})," ",(0,o.jsx)(n.code,{children:"0x42"})," in ",(0,o.jsx)(n.a,{href:"/move/book/global-storage-structure",children:"global storage"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Modules can also be declared using ",(0,o.jsx)(n.a,{href:"/move/book/address",children:"named addresses"}),". For example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module example_addr::example {\n    struct Example has copy, drop { a: address }\n\n    use std::debug;\n    friend example_addr::another_example;\n\n    public fun print() {\n        let example = Example { a: @example_addr };\n        debug::print(&example)\n    }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Because named addresses only exist at the source language level and during compilation,\nnamed addresses will be fully substituted for their value at the bytecode\nlevel. For example if we had the following code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"script {\n    fun example() {\n        my_addr::m::foo(@my_addr);\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["and we compiled it with ",(0,o.jsx)(n.code,{children:"my_addr"})," set to ",(0,o.jsx)(n.code,{children:"0xC0FFEE"}),", then it would be equivalent\nto the following operationally:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"script {\n    fun example() {\n        0xC0FFEE::m::foo(@0xC0FFEE);\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["However, at the source level, these ",(0,o.jsx)(n.em,{children:"are not equivalent"}),"\u2014the function\n",(0,o.jsx)(n.code,{children:"m::foo"})," ",(0,o.jsx)(n.em,{children:"must"})," be accessed through the ",(0,o.jsx)(n.code,{children:"my_addr"})," named address, and not through\nthe numerical value assigned to that address."]}),"\n",(0,o.jsxs)(n.p,{children:["Module names can start with letters ",(0,o.jsx)(n.code,{children:"a"})," to ",(0,o.jsx)(n.code,{children:"z"})," or letters ",(0,o.jsx)(n.code,{children:"A"})," to ",(0,o.jsx)(n.code,{children:"Z"}),". After the first character, module names can contain underscores ",(0,o.jsx)(n.code,{children:"_"}),", letters ",(0,o.jsx)(n.code,{children:"a"})," to ",(0,o.jsx)(n.code,{children:"z"}),", letters ",(0,o.jsx)(n.code,{children:"A"})," to ",(0,o.jsx)(n.code,{children:"Z"}),", or digits ",(0,o.jsx)(n.code,{children:"0"})," to ",(0,o.jsx)(n.code,{children:"9"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"module my_module {}\nmodule foo_bar_42 {}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Typically, module names start with a lowercase letter. A module named ",(0,o.jsx)(n.code,{children:"my_module"})," should be stored in a source file named ",(0,o.jsx)(n.code,{children:"my_module.move"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["All elements inside a ",(0,o.jsx)(n.code,{children:"module"})," block can appear in any order.\nFundamentally, a module is a collection of ",(0,o.jsx)(n.a,{href:"/move/book/structs-and-resources",children:(0,o.jsx)(n.code,{children:"types"})})," and ",(0,o.jsx)(n.a,{href:"/move/book/functions",children:(0,o.jsx)(n.code,{children:"functions"})}),".\nThe ",(0,o.jsx)(n.a,{href:"/move/book/uses",children:(0,o.jsx)(n.code,{children:"use"})})," keyword is used to import types from other modules.\nThe ",(0,o.jsx)(n.a,{href:"/move/book/friends",children:(0,o.jsx)(n.code,{children:"friend"})})," keyword specifies a list of trusted modules.\nThe ",(0,o.jsx)(n.a,{href:"/move/book/constants",children:(0,o.jsx)(n.code,{children:"const"})})," keyword defines private constants that can be used in the functions of a module."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},83581:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>d});var o=s(11855);const t={},r=o.createContext(t);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);