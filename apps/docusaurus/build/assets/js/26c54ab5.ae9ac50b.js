"use strict";(self.webpackChunkaptos_docs=self.webpackChunkaptos_docs||[]).push([[933],{85696:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>c,toc:()=>d});var o=r(63159),s=r(83581);const t={},a="Global Storage - Operators",c={id:"move/book/global-storage-operators",title:"Global Storage - Operators",description:"Move programs can create, delete, and update resources in global storage using the following five instructions:",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/move/book/global-storage-operators.md",sourceDirName:"move/book",slug:"/move/book/global-storage-operators",permalink:"/move/book/global-storage-operators",draft:!1,unlisted:!1,editUrl:"https://github.com/aptos-labs/developer-docs/edit/main/apps/docusaurus/docs/move/book/global-storage-operators.md",tags:[],version:"current",lastUpdatedAt:1713276994,formattedLastUpdatedAt:"2024\u5e744\u670816\u65e5",frontMatter:{},sidebar:"appSidebar",previous:{title:"Global Storage - Structure",permalink:"/move/book/global-storage-structure"},next:{title:"\u30e9\u30a4\u30d6\u30e9\u30ea",permalink:"/move/book/standard-library"}},i={},d=[{value:"References to resources",id:"references-to-resources",level:2},{value:"Global storage operators with generics",id:"global-storage-operators-with-generics",level:2},{value:"Example: <code>Counter</code>",id:"example-counter",level:2},{value:"Annotating functions with <code>acquires</code>",id:"annotating-functions-with-acquires",level:2},{value:"Reference Safety For Global Resources",id:"reference-safety-for-global-resources",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"global-storage---operators",children:"Global Storage - Operators"}),"\n",(0,o.jsxs)(n.p,{children:["Move programs can create, delete, and update ",(0,o.jsx)(n.a,{href:"/move/book/structs-and-resources",children:"resources"})," in global storage using the following five instructions:"]}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Operation"}),(0,o.jsx)(n.th,{children:"Description"}),(0,o.jsx)(n.th,{children:"Aborts?"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"move_to<T>(&signer,T)"})}),(0,o.jsxs)(n.td,{children:["Publish ",(0,o.jsx)(n.code,{children:"T"})," under ",(0,o.jsx)(n.code,{children:"signer.address"})]}),(0,o.jsxs)(n.td,{children:["If ",(0,o.jsx)(n.code,{children:"signer.address"})," already holds a ",(0,o.jsx)(n.code,{children:"T"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"move_from<T>(address): T"})}),(0,o.jsxs)(n.td,{children:["Remove ",(0,o.jsx)(n.code,{children:"T"})," from ",(0,o.jsx)(n.code,{children:"address"})," and return it"]}),(0,o.jsxs)(n.td,{children:["If ",(0,o.jsx)(n.code,{children:"address"})," does not hold a ",(0,o.jsx)(n.code,{children:"T"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"borrow_global_mut<T>(address): &mut T"})}),(0,o.jsxs)(n.td,{children:["Return a mutable reference to the ",(0,o.jsx)(n.code,{children:"T"})," stored under ",(0,o.jsx)(n.code,{children:"address"})]}),(0,o.jsxs)(n.td,{children:["If ",(0,o.jsx)(n.code,{children:"address"})," does not hold a ",(0,o.jsx)(n.code,{children:"T"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"borrow_global<T>(address): &T"})}),(0,o.jsxs)(n.td,{children:["Return an immutable reference to the ",(0,o.jsx)(n.code,{children:"T"})," stored under ",(0,o.jsx)(n.code,{children:"address"})]}),(0,o.jsxs)(n.td,{children:["If ",(0,o.jsx)(n.code,{children:"address"})," does not hold a ",(0,o.jsx)(n.code,{children:"T"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"exists<T>(address): bool"})}),(0,o.jsxs)(n.td,{children:["Return ",(0,o.jsx)(n.code,{children:"true"})," if a ",(0,o.jsx)(n.code,{children:"T"})," is stored under ",(0,o.jsx)(n.code,{children:"address"})]}),(0,o.jsx)(n.td,{children:"Never"})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:["Each of these instructions is parameterized by a type ",(0,o.jsx)(n.code,{children:"T"})," with the ",(0,o.jsxs)(n.a,{href:"/move/book/abilities",children:[(0,o.jsx)(n.code,{children:"key"})," ability"]}),". However, each type ",(0,o.jsx)(n.code,{children:"T"})," ",(0,o.jsx)(n.em,{children:"must be declared in the current module"}),". This ensures that a resource can only be manipulated via the API exposed by its defining module. The instructions also take either an ",(0,o.jsx)(n.a,{href:"/move/book/address",children:(0,o.jsx)(n.code,{children:"address"})})," or ",(0,o.jsx)(n.a,{href:"/move/book/signer",children:(0,o.jsx)(n.code,{children:"&signer"})})," representing the account address where the resource of type ",(0,o.jsx)(n.code,{children:"T"})," is stored."]}),"\n",(0,o.jsx)(n.h2,{id:"references-to-resources",children:"References to resources"}),"\n",(0,o.jsxs)(n.p,{children:["References to global resources returned by ",(0,o.jsx)(n.code,{children:"borrow_global"})," or ",(0,o.jsx)(n.code,{children:"borrow_global_mut"})," mostly behave like references to local storage: they can be extended, read, and written using ordinary ",(0,o.jsx)(n.a,{href:"/move/book/references",children:"reference operators"})," and passed as arguments to other function. However, there is one important difference between local and global references: ",(0,o.jsx)(n.strong,{children:"a function cannot return a reference that points into global storage"}),". For example, these two functions will each fail to compile:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"struct R has key { f: u64 }\n// will not compile\nfun ret_direct_resource_ref_bad(a: address): &R {\n    borrow_global<R>(a) // error!\n}\n// also will not compile\nfun ret_resource_field_ref_bad(a: address): &u64 {\n    &borrow_global<R>(a).f // error!\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Move must enforce this restriction to guarantee absence of dangling references to global storage. ",(0,o.jsx)(n.a,{href:"#reference-safety-for-global-resources",children:"This"})," section contains much more detail for the interested reader."]}),"\n",(0,o.jsx)(n.h2,{id:"global-storage-operators-with-generics",children:"Global storage operators with generics"}),"\n",(0,o.jsx)(n.p,{children:"Global storage operations can be applied to generic resources with both instantiated and uninstantiated generic type parameters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"struct Container<T> has key { t: T }\n\n// Publish a Container storing a type T of the caller's choosing\nfun publish_generic_container<T>(account: &signer, t: T) {\n    move_to<Container<T>>(account, Container { t })\n}\n\n/// Publish a container storing a u64\nfun publish_instantiated_generic_container(account: &signer, t: u64) {\n    move_to<Container<u64>>(account, Container { t })\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ability to index into global storage via a type parameter chosen at runtime is a powerful Move feature known as ",(0,o.jsx)(n.em,{children:"storage polymorphism"}),". For more on the design patterns enabled by this feature, see ",(0,o.jsx)(n.a,{href:"/move/book/generics",children:"Move generics"}),"."]}),"\n",(0,o.jsxs)(n.h2,{id:"example-counter",children:["Example: ",(0,o.jsx)(n.code,{children:"Counter"})]}),"\n",(0,o.jsxs)(n.p,{children:["The simple ",(0,o.jsx)(n.code,{children:"Counter"})," module below exercises each of the five global storage operators. The API exposed by this module allows:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Anyone to publish a ",(0,o.jsx)(n.code,{children:"Counter"})," resource under their account"]}),"\n",(0,o.jsxs)(n.li,{children:["Anyone to check if a ",(0,o.jsx)(n.code,{children:"Counter"})," exists under any address"]}),"\n",(0,o.jsxs)(n.li,{children:["Anyone to read or increment the value of a ",(0,o.jsx)(n.code,{children:"Counter"})," resource under any address"]}),"\n",(0,o.jsxs)(n.li,{children:["An account that stores a ",(0,o.jsx)(n.code,{children:"Counter"})," resource to reset it to zero"]}),"\n",(0,o.jsxs)(n.li,{children:["An account that stores a ",(0,o.jsx)(n.code,{children:"Counter"})," resource to remove and delete it"]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:'address 0x42 {\nmodule counter {\n    use std::signer;\n\n    /// Resource that wraps an integer counter\n    struct Counter has key { i: u64 }\n\n    /// Publish a `Counter` resource with value `i` under the given `account`\n    public fun publish(account: &signer, i: u64) {\n      // "Pack" (create) a Counter resource. This is a privileged operation that\n      // can only be done inside the module that declares the `Counter` resource\n      move_to(account, Counter { i })\n    }\n\n    /// Read the value in the `Counter` resource stored at `addr`\n    public fun get_count(addr: address): u64 acquires Counter {\n        borrow_global<Counter>(addr).i\n    }\n\n    /// Increment the value of `addr`\'s `Counter` resource\n    public fun increment(addr: address) acquires Counter {\n        let c_ref = &mut borrow_global_mut<Counter>(addr).i;\n        *c_ref = *c_ref + 1\n    }\n\n    /// Reset the value of `account`\'s `Counter` to 0\n    public fun reset(account: &signer) acquires Counter {\n        let c_ref = &mut borrow_global_mut<Counter>(signer::address_of(account)).i;\n        *c_ref = 0\n    }\n\n    /// Delete the `Counter` resource under `account` and return its value\n    public fun delete(account: &signer): u64 acquires Counter {\n        // remove the Counter resource\n        let c = move_from<Counter>(signer::address_of(account));\n        // "Unpack" the `Counter` resource into its fields. This is a\n        // privileged operation that can only be done inside the module\n        // that declares the `Counter` resource\n        let Counter { i } = c;\n        i\n    }\n\n    /// Return `true` if `addr` contains a `Counter` resource\n    public fun exists(addr: address): bool {\n        exists<Counter>(addr)\n    }\n}\n}\n'})}),"\n",(0,o.jsxs)(n.h2,{id:"annotating-functions-with-acquires",children:["Annotating functions with ",(0,o.jsx)(n.code,{children:"acquires"})]}),"\n",(0,o.jsxs)(n.p,{children:["In the ",(0,o.jsx)(n.code,{children:"counter"})," example, you might have noticed that the ",(0,o.jsx)(n.code,{children:"get_count"}),", ",(0,o.jsx)(n.code,{children:"increment"}),", ",(0,o.jsx)(n.code,{children:"reset"}),", and ",(0,o.jsx)(n.code,{children:"delete"})," functions are annotated with ",(0,o.jsx)(n.code,{children:"acquires Counter"}),". A Move function ",(0,o.jsx)(n.code,{children:"m::f"})," must be annotated with ",(0,o.jsx)(n.code,{children:"acquires T"})," if and only if:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The body of ",(0,o.jsx)(n.code,{children:"m::f"})," contains a ",(0,o.jsx)(n.code,{children:"move_from<T>"}),", ",(0,o.jsx)(n.code,{children:"borrow_global_mut<T>"}),", or ",(0,o.jsx)(n.code,{children:"borrow_global<T>"})," instruction, or"]}),"\n",(0,o.jsxs)(n.li,{children:["The body of ",(0,o.jsx)(n.code,{children:"m::f"})," invokes a function ",(0,o.jsx)(n.code,{children:"m::g"})," declared in the same module that is annotated with ",(0,o.jsx)(n.code,{children:"acquires"})]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["For example, the following function inside ",(0,o.jsx)(n.code,{children:"Counter"})," would need an ",(0,o.jsx)(n.code,{children:"acquires"})," annotation:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"// Needs `acquires` because `increment` is annotated with `acquires`\nfun call_increment(addr: address): u64 acquires Counter {\n    counter::increment(addr)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["However, the same function ",(0,o.jsx)(n.em,{children:"outside"})," ",(0,o.jsx)(n.code,{children:"Counter"})," would not need an annotation:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"address 0x43 {\nmodule m {\n   use 0x42::counter;\n\n   // Ok. Only need annotation when resource acquired by callee is declared\n   // in the same module\n   fun call_increment(addr: address): u64 {\n       counter::increment(addr)\n   }\n}\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["If a function touches multiple resources, it needs multiple ",(0,o.jsx)(n.code,{children:"acquires"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule two_resources {\n    struct R1 has key { f: u64 }\n    struct R2 has key { g: u64 }\n\n    fun double_acquires(a: address): u64 acquires R1, R2 {\n        borrow_global<R1>(a).f + borrow_global<R2>.g\n    }\n}\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"acquires"})," annotation does not take generic type parameters into account:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule m {\n    struct R<T> has key { t: T }\n\n    // `acquires R`, not `acquires R<T>`\n    fun acquire_generic_resource<T: store>(a: addr) acquires R {\n        let _ = borrow_global<R<T>>(a);\n    }\n\n    // `acquires R`, not `acquires R<u64>\n    fun acquire_instantiated_generic_resource(a: addr) acquires R {\n        let _ = borrow_global<R<u64>>(a);\n    }\n}\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Finally: redundant ",(0,o.jsx)(n.code,{children:"acquires"})," are not allowed. Adding this function inside ",(0,o.jsx)(n.code,{children:"Counter"})," will result in a compilation error:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"// This code will not compile because the body of the function does not use a global\n// storage instruction or invoke a function with `acquires`\nfun redundant_acquires_bad() acquires Counter {}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["For more information on ",(0,o.jsx)(n.code,{children:"acquires"}),", see ",(0,o.jsx)(n.a,{href:"/move/book/functions",children:"Move functions"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"reference-safety-for-global-resources",children:"Reference Safety For Global Resources"}),"\n",(0,o.jsxs)(n.p,{children:["Move prohibits returning global references and requires the ",(0,o.jsx)(n.code,{children:"acquires"})," annotation to prevent dangling references. This allows Move to live up to its promise of static reference safety (i.e., no dangling references, no ",(0,o.jsx)(n.code,{children:"null"})," or ",(0,o.jsx)(n.code,{children:"nil"})," dereferences) for all ",(0,o.jsx)(n.a,{href:"/move/book/references",children:"reference"})," types."]}),"\n",(0,o.jsxs)(n.p,{children:["This example illustrates how the Move type system uses ",(0,o.jsx)(n.code,{children:"acquires"})," to prevent a dangling reference:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule dangling {\n    struct T has key { f: u64 }\n\n    fun borrow_then_remove_bad(a: address) acquires T {\n        let t_ref: &mut T = borrow_global_mut<T>(a);\n        let t = remove_t(a); // type system complains here\n        // t_ref now dangling!\n        let uh_oh = *&t_ref.f\n    }\n\n    fun remove_t(a: address): T acquires T {\n        move_from<T>(a)\n    }\n\n}\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this code, line 6 acquires a reference to the ",(0,o.jsx)(n.code,{children:"T"})," stored at address ",(0,o.jsx)(n.code,{children:"a"})," in global storage. The callee ",(0,o.jsx)(n.code,{children:"remove_t"})," then removes the value, which makes ",(0,o.jsx)(n.code,{children:"t_ref"})," a dangling reference."]}),"\n",(0,o.jsxs)(n.p,{children:["Fortunately, this cannot happen because the type system will reject this program. The ",(0,o.jsx)(n.code,{children:"acquires"})," annotation on ",(0,o.jsx)(n.code,{children:"remove_t"})," lets the type system know that line 7 is dangerous, without having to recheck or introspect the body of ",(0,o.jsx)(n.code,{children:"remove_t"})," separately!"]}),"\n",(0,o.jsx)(n.p,{children:"The restriction on returning global references prevents a similar, but even more insidious problem:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-move",children:"address 0x42 {\nmodule m1 {\n    struct T has key {}\n\n    public fun ret_t_ref(a: address): &T acquires T {\n        borrow_global<T>(a) // error! type system complains here\n    }\n\n    public fun remove_t(a: address) acquires T {\n        let T {} = move_from<T>(a);\n    }\n}\n\nmodule m2 {\n    fun borrow_then_remove_bad(a: address) {\n        let t_ref = m1::ret_t_ref(a);\n        let t = m1::remove_t(a); // t_ref now dangling!\n    }\n}\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Line 16 acquires a reference to a global resource ",(0,o.jsx)(n.code,{children:"m1::T"}),", then line 17 removes that same resource, which makes ",(0,o.jsx)(n.code,{children:"t_ref"})," dangle. In this case, ",(0,o.jsx)(n.code,{children:"acquires"})," annotations do not help us because the ",(0,o.jsx)(n.code,{children:"borrow_then_remove_bad"})," function is outside the ",(0,o.jsx)(n.code,{children:"m1"})," module that declares ",(0,o.jsx)(n.code,{children:"T"})," (recall that ",(0,o.jsx)(n.code,{children:"acquires"})," annotations can only be used for resources declared in the current module). Instead, the type system avoids this problem by preventing the return of a global reference at line 6."]}),"\n",(0,o.jsx)(n.p,{children:"Fancier type systems that would allow returning global references without sacrificing reference safety are possible, and we may consider them in future iterations of Move. We chose the current design because it strikes a good balance between being expressive, annotation burden, and type system complexity."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},83581:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var o=r(11855);const s={},t=o.createContext(s);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);